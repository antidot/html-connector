/*
 File: handlebars.js */
(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{1950:function(g,f,b){b(1951);b(1953);b(1954)},1951:function(g,f,b){b(12)(b(1952))},1952:function(g,f){g.exports="/*!\n\n handlebars v3.0.3\n\nCopyright (C) 2011-2014 by Yehuda Katz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n@license\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports \x3d\x3d\x3d 'object' \x26\x26 typeof module \x3d\x3d\x3d 'object')\n\t\tmodule.exports \x3d factory();\n\telse if(typeof define \x3d\x3d\x3d 'function' \x26\x26 define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports \x3d\x3d\x3d 'object')\n\t\texports[\"Handlebars\"] \x3d factory();\n\telse\n\t\troot[\"Handlebars\"] \x3d factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules \x3d {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module \x3d installedModules[moduleId] \x3d {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded \x3d true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m \x3d modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c \x3d installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p \x3d \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\n\tvar _runtime \x3d __webpack_require__(1);\n\n\tvar _runtime2 \x3d _interopRequireDefault(_runtime);\n\n\t// Compiler imports\n\n\tvar _AST \x3d __webpack_require__(2);\n\n\tvar _AST2 \x3d _interopRequireDefault(_AST);\n\n\tvar _Parser$parse \x3d __webpack_require__(3);\n\n\tvar _Compiler$compile$precompile \x3d __webpack_require__(4);\n\n\tvar _JavaScriptCompiler \x3d __webpack_require__(5);\n\n\tvar _JavaScriptCompiler2 \x3d _interopRequireDefault(_JavaScriptCompiler);\n\n\tvar _Visitor \x3d __webpack_require__(6);\n\n\tvar _Visitor2 \x3d _interopRequireDefault(_Visitor);\n\n\tvar _noConflict \x3d __webpack_require__(7);\n\n\tvar _noConflict2 \x3d _interopRequireDefault(_noConflict);\n\n\tvar _create \x3d _runtime2['default'].create;\n\tfunction create() {\n\t  var hb \x3d _create();\n\n\t  hb.compile \x3d function (input, options) {\n\t    return _Compiler$compile$precompile.compile(input, options, hb);\n\t  };\n\t  hb.precompile \x3d function (input, options) {\n\t    return _Compiler$compile$precompile.precompile(input, options, hb);\n\t  };\n\n\t  hb.AST \x3d _AST2['default'];\n\t  hb.Compiler \x3d _Compiler$compile$precompile.Compiler;\n\t  hb.JavaScriptCompiler \x3d _JavaScriptCompiler2['default'];\n\t  hb.Parser \x3d _Parser$parse.parser;\n\t  hb.parse \x3d _Parser$parse.parse;\n\n\t  return hb;\n\t}\n\n\tvar inst \x3d create();\n\tinst.create \x3d create;\n\n\t_noConflict2['default'](inst);\n\n\tinst.Visitor \x3d _Visitor2['default'];\n\n\tinst['default'] \x3d inst;\n\n\texports['default'] \x3d inst;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireWildcard \x3d __webpack_require__(9)['default'];\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\n\tvar _import \x3d __webpack_require__(10);\n\n\tvar base \x3d _interopRequireWildcard(_import);\n\n\t// Each of these augment the Handlebars object. No need to setup here.\n\t// (This is done to easily share code between commonjs and browse envs)\n\n\tvar _SafeString \x3d __webpack_require__(11);\n\n\tvar _SafeString2 \x3d _interopRequireDefault(_SafeString);\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar _import2 \x3d __webpack_require__(13);\n\n\tvar Utils \x3d _interopRequireWildcard(_import2);\n\n\tvar _import3 \x3d __webpack_require__(14);\n\n\tvar runtime \x3d _interopRequireWildcard(_import3);\n\n\tvar _noConflict \x3d __webpack_require__(7);\n\n\tvar _noConflict2 \x3d _interopRequireDefault(_noConflict);\n\n\t// For compatibility and usage outside of module systems, make the Handlebars object a namespace\n\tfunction create() {\n\t  var hb \x3d new base.HandlebarsEnvironment();\n\n\t  Utils.extend(hb, base);\n\t  hb.SafeString \x3d _SafeString2['default'];\n\t  hb.Exception \x3d _Exception2['default'];\n\t  hb.Utils \x3d Utils;\n\t  hb.escapeExpression \x3d Utils.escapeExpression;\n\n\t  hb.VM \x3d runtime;\n\t  hb.template \x3d function (spec) {\n\t    return runtime.template(spec, hb);\n\t  };\n\n\t  return hb;\n\t}\n\n\tvar inst \x3d create();\n\tinst.create \x3d create;\n\n\t_noConflict2['default'](inst);\n\n\tinst['default'] \x3d inst;\n\n\texports['default'] \x3d inst;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule \x3d true;\n\tvar AST \x3d {\n\t  Program: function Program(statements, blockParams, strip, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'Program';\n\t    this.body \x3d statements;\n\n\t    this.blockParams \x3d blockParams;\n\t    this.strip \x3d strip;\n\t  },\n\n\t  MustacheStatement: function MustacheStatement(path, params, hash, escaped, strip, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'MustacheStatement';\n\n\t    this.path \x3d path;\n\t    this.params \x3d params || [];\n\t    this.hash \x3d hash;\n\t    this.escaped \x3d escaped;\n\n\t    this.strip \x3d strip;\n\t  },\n\n\t  BlockStatement: function BlockStatement(path, params, hash, program, inverse, openStrip, inverseStrip, closeStrip, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'BlockStatement';\n\n\t    this.path \x3d path;\n\t    this.params \x3d params || [];\n\t    this.hash \x3d hash;\n\t    this.program \x3d program;\n\t    this.inverse \x3d inverse;\n\n\t    this.openStrip \x3d openStrip;\n\t    this.inverseStrip \x3d inverseStrip;\n\t    this.closeStrip \x3d closeStrip;\n\t  },\n\n\t  PartialStatement: function PartialStatement(name, params, hash, strip, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'PartialStatement';\n\n\t    this.name \x3d name;\n\t    this.params \x3d params || [];\n\t    this.hash \x3d hash;\n\n\t    this.indent \x3d '';\n\t    this.strip \x3d strip;\n\t  },\n\n\t  ContentStatement: function ContentStatement(string, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'ContentStatement';\n\t    this.original \x3d this.value \x3d string;\n\t  },\n\n\t  CommentStatement: function CommentStatement(comment, strip, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'CommentStatement';\n\t    this.value \x3d comment;\n\n\t    this.strip \x3d strip;\n\t  },\n\n\t  SubExpression: function SubExpression(path, params, hash, locInfo) {\n\t    this.loc \x3d locInfo;\n\n\t    this.type \x3d 'SubExpression';\n\t    this.path \x3d path;\n\t    this.params \x3d params || [];\n\t    this.hash \x3d hash;\n\t  },\n\n\t  PathExpression: function PathExpression(data, depth, parts, original, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'PathExpression';\n\n\t    this.data \x3d data;\n\t    this.original \x3d original;\n\t    this.parts \x3d parts;\n\t    this.depth \x3d depth;\n\t  },\n\n\t  StringLiteral: function StringLiteral(string, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'StringLiteral';\n\t    this.original \x3d this.value \x3d string;\n\t  },\n\n\t  NumberLiteral: function NumberLiteral(number, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'NumberLiteral';\n\t    this.original \x3d this.value \x3d Number(number);\n\t  },\n\n\t  BooleanLiteral: function BooleanLiteral(bool, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'BooleanLiteral';\n\t    this.original \x3d this.value \x3d bool \x3d\x3d\x3d 'true';\n\t  },\n\n\t  UndefinedLiteral: function UndefinedLiteral(locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'UndefinedLiteral';\n\t    this.original \x3d this.value \x3d undefined;\n\t  },\n\n\t  NullLiteral: function NullLiteral(locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'NullLiteral';\n\t    this.original \x3d this.value \x3d null;\n\t  },\n\n\t  Hash: function Hash(pairs, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'Hash';\n\t    this.pairs \x3d pairs;\n\t  },\n\t  HashPair: function HashPair(key, value, locInfo) {\n\t    this.loc \x3d locInfo;\n\t    this.type \x3d 'HashPair';\n\t    this.key \x3d key;\n\t    this.value \x3d value;\n\t  },\n\n\t  // Public API used to evaluate derived attributes regarding AST nodes\n\t  helpers: {\n\t    // a mustache is definitely a helper if:\n\t    // * it is an eligible helper, and\n\t    // * it has at least one parameter or hash segment\n\t    helperExpression: function helperExpression(node) {\n\t      return !!(node.type \x3d\x3d\x3d 'SubExpression' || node.params.length || node.hash);\n\t    },\n\n\t    scopedId: function scopedId(path) {\n\t      return /^\\.|this\\b/.test(path.original);\n\t    },\n\n\t    // an ID is simple if it only has one part, and that part is not\n\t    // `..` or `this`.\n\t    simpleId: function simpleId(path) {\n\t      return path.parts.length \x3d\x3d\x3d 1 \x26\x26 !AST.helpers.scopedId(path) \x26\x26 !path.depth;\n\t    }\n\t  }\n\t};\n\n\t// Must be exported as an object rather than the root of the module as the jison lexer\n\t// must modify the object to operate properly.\n\texports['default'] \x3d AST;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\tvar _interopRequireWildcard \x3d __webpack_require__(9)['default'];\n\n\texports.__esModule \x3d true;\n\texports.parse \x3d parse;\n\n\tvar _parser \x3d __webpack_require__(15);\n\n\tvar _parser2 \x3d _interopRequireDefault(_parser);\n\n\tvar _AST \x3d __webpack_require__(2);\n\n\tvar _AST2 \x3d _interopRequireDefault(_AST);\n\n\tvar _WhitespaceControl \x3d __webpack_require__(16);\n\n\tvar _WhitespaceControl2 \x3d _interopRequireDefault(_WhitespaceControl);\n\n\tvar _import \x3d __webpack_require__(17);\n\n\tvar Helpers \x3d _interopRequireWildcard(_import);\n\n\tvar _extend \x3d __webpack_require__(13);\n\n\texports.parser \x3d _parser2['default'];\n\n\tvar yy \x3d {};\n\t_extend.extend(yy, Helpers, _AST2['default']);\n\n\tfunction parse(input, options) {\n\t  // Just return if an already-compiled AST was passed in.\n\t  if (input.type \x3d\x3d\x3d 'Program') {\n\t    return input;\n\t  }\n\n\t  _parser2['default'].yy \x3d yy;\n\n\t  // Altering the shared object here, but this is ok as parser is a sync operation\n\t  yy.locInfo \x3d function (locInfo) {\n\t    return new yy.SourceLocation(options \x26\x26 options.srcName, locInfo);\n\t  };\n\n\t  var strip \x3d new _WhitespaceControl2['default']();\n\t  return strip.accept(_parser2['default'].parse(input));\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\texports.Compiler \x3d Compiler;\n\texports.precompile \x3d precompile;\n\texports.compile \x3d compile;\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar _isArray$indexOf \x3d __webpack_require__(13);\n\n\tvar _AST \x3d __webpack_require__(2);\n\n\tvar _AST2 \x3d _interopRequireDefault(_AST);\n\n\tvar slice \x3d [].slice;\n\n\tfunction Compiler() {}\n\n\t// the foundHelper register will disambiguate helper lookup from finding a\n\t// function in a context. This is necessary for mustache compatibility, which\n\t// requires that context functions in blocks are evaluated by blockHelperMissing,\n\t// and then proceed as if the resulting value was provided to blockHelperMissing.\n\n\tCompiler.prototype \x3d {\n\t  compiler: Compiler,\n\n\t  equals: function equals(other) {\n\t    var len \x3d this.opcodes.length;\n\t    if (other.opcodes.length !\x3d\x3d len) {\n\t      return false;\n\t    }\n\n\t    for (var i \x3d 0; i \x3c len; i++) {\n\t      var opcode \x3d this.opcodes[i],\n\t          otherOpcode \x3d other.opcodes[i];\n\t      if (opcode.opcode !\x3d\x3d otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n\t        return false;\n\t      }\n\t    }\n\n\t    // We know that length is the same between the two arrays because they are directly tied\n\t    // to the opcode behavior above.\n\t    len \x3d this.children.length;\n\t    for (var i \x3d 0; i \x3c len; i++) {\n\t      if (!this.children[i].equals(other.children[i])) {\n\t        return false;\n\t      }\n\t    }\n\n\t    return true;\n\t  },\n\n\t  guid: 0,\n\n\t  compile: function compile(program, options) {\n\t    this.sourceNode \x3d [];\n\t    this.opcodes \x3d [];\n\t    this.children \x3d [];\n\t    this.options \x3d options;\n\t    this.stringParams \x3d options.stringParams;\n\t    this.trackIds \x3d options.trackIds;\n\n\t    options.blockParams \x3d options.blockParams || [];\n\n\t    // These changes will propagate to the other compiler components\n\t    var knownHelpers \x3d options.knownHelpers;\n\t    options.knownHelpers \x3d {\n\t      helperMissing: true,\n\t      blockHelperMissing: true,\n\t      each: true,\n\t      'if': true,\n\t      unless: true,\n\t      'with': true,\n\t      log: true,\n\t      lookup: true\n\t    };\n\t    if (knownHelpers) {\n\t      for (var _name in knownHelpers) {\n\t        if (_name in knownHelpers) {\n\t          options.knownHelpers[_name] \x3d knownHelpers[_name];\n\t        }\n\t      }\n\t    }\n\n\t    return this.accept(program);\n\t  },\n\n\t  compileProgram: function compileProgram(program) {\n\t    var childCompiler \x3d new this.compiler(),\n\t        // eslint-disable-line new-cap\n\t    result \x3d childCompiler.compile(program, this.options),\n\t        guid \x3d this.guid++;\n\n\t    this.usePartial \x3d this.usePartial || result.usePartial;\n\n\t    this.children[guid] \x3d result;\n\t    this.useDepths \x3d this.useDepths || result.useDepths;\n\n\t    return guid;\n\t  },\n\n\t  accept: function accept(node) {\n\t    this.sourceNode.unshift(node);\n\t    var ret \x3d this[node.type](node);\n\t    this.sourceNode.shift();\n\t    return ret;\n\t  },\n\n\t  Program: function Program(program) {\n\t    this.options.blockParams.unshift(program.blockParams);\n\n\t    var body \x3d program.body,\n\t        bodyLength \x3d body.length;\n\t    for (var i \x3d 0; i \x3c bodyLength; i++) {\n\t      this.accept(body[i]);\n\t    }\n\n\t    this.options.blockParams.shift();\n\n\t    this.isSimple \x3d bodyLength \x3d\x3d\x3d 1;\n\t    this.blockParams \x3d program.blockParams ? program.blockParams.length : 0;\n\n\t    return this;\n\t  },\n\n\t  BlockStatement: function BlockStatement(block) {\n\t    transformLiteralToPath(block);\n\n\t    var program \x3d block.program,\n\t        inverse \x3d block.inverse;\n\n\t    program \x3d program \x26\x26 this.compileProgram(program);\n\t    inverse \x3d inverse \x26\x26 this.compileProgram(inverse);\n\n\t    var type \x3d this.classifySexpr(block);\n\n\t    if (type \x3d\x3d\x3d 'helper') {\n\t      this.helperSexpr(block, program, inverse);\n\t    } else if (type \x3d\x3d\x3d 'simple') {\n\t      this.simpleSexpr(block);\n\n\t      // now that the simple mustache is resolved, we need to\n\t      // evaluate it by executing `blockHelperMissing`\n\t      this.opcode('pushProgram', program);\n\t      this.opcode('pushProgram', inverse);\n\t      this.opcode('emptyHash');\n\t      this.opcode('blockValue', block.path.original);\n\t    } else {\n\t      this.ambiguousSexpr(block, program, inverse);\n\n\t      // now that the simple mustache is resolved, we need to\n\t      // evaluate it by executing `blockHelperMissing`\n\t      this.opcode('pushProgram', program);\n\t      this.opcode('pushProgram', inverse);\n\t      this.opcode('emptyHash');\n\t      this.opcode('ambiguousBlockValue');\n\t    }\n\n\t    this.opcode('append');\n\t  },\n\n\t  PartialStatement: function PartialStatement(partial) {\n\t    this.usePartial \x3d true;\n\n\t    var params \x3d partial.params;\n\t    if (params.length \x3e 1) {\n\t      throw new _Exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n\t    } else if (!params.length) {\n\t      params.push({ type: 'PathExpression', parts: [], depth: 0 });\n\t    }\n\n\t    var partialName \x3d partial.name.original,\n\t        isDynamic \x3d partial.name.type \x3d\x3d\x3d 'SubExpression';\n\t    if (isDynamic) {\n\t      this.accept(partial.name);\n\t    }\n\n\t    this.setupFullMustacheParams(partial, undefined, undefined, true);\n\n\t    var indent \x3d partial.indent || '';\n\t    if (this.options.preventIndent \x26\x26 indent) {\n\t      this.opcode('appendContent', indent);\n\t      indent \x3d '';\n\t    }\n\n\t    this.opcode('invokePartial', isDynamic, partialName, indent);\n\t    this.opcode('append');\n\t  },\n\n\t  MustacheStatement: function MustacheStatement(mustache) {\n\t    this.SubExpression(mustache); // eslint-disable-line new-cap\n\n\t    if (mustache.escaped \x26\x26 !this.options.noEscape) {\n\t      this.opcode('appendEscaped');\n\t    } else {\n\t      this.opcode('append');\n\t    }\n\t  },\n\n\t  ContentStatement: function ContentStatement(content) {\n\t    if (content.value) {\n\t      this.opcode('appendContent', content.value);\n\t    }\n\t  },\n\n\t  CommentStatement: function CommentStatement() {},\n\n\t  SubExpression: function SubExpression(sexpr) {\n\t    transformLiteralToPath(sexpr);\n\t    var type \x3d this.classifySexpr(sexpr);\n\n\t    if (type \x3d\x3d\x3d 'simple') {\n\t      this.simpleSexpr(sexpr);\n\t    } else if (type \x3d\x3d\x3d 'helper') {\n\t      this.helperSexpr(sexpr);\n\t    } else {\n\t      this.ambiguousSexpr(sexpr);\n\t    }\n\t  },\n\t  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n\t    var path \x3d sexpr.path,\n\t        name \x3d path.parts[0],\n\t        isBlock \x3d program !\x3d null || inverse !\x3d null;\n\n\t    this.opcode('getContext', path.depth);\n\n\t    this.opcode('pushProgram', program);\n\t    this.opcode('pushProgram', inverse);\n\n\t    this.accept(path);\n\n\t    this.opcode('invokeAmbiguous', name, isBlock);\n\t  },\n\n\t  simpleSexpr: function simpleSexpr(sexpr) {\n\t    this.accept(sexpr.path);\n\t    this.opcode('resolvePossibleLambda');\n\t  },\n\n\t  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n\t    var params \x3d this.setupFullMustacheParams(sexpr, program, inverse),\n\t        path \x3d sexpr.path,\n\t        name \x3d path.parts[0];\n\n\t    if (this.options.knownHelpers[name]) {\n\t      this.opcode('invokeKnownHelper', params.length, name);\n\t    } else if (this.options.knownHelpersOnly) {\n\t      throw new _Exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n\t    } else {\n\t      path.falsy \x3d true;\n\n\t      this.accept(path);\n\t      this.opcode('invokeHelper', params.length, path.original, _AST2['default'].helpers.simpleId(path));\n\t    }\n\t  },\n\n\t  PathExpression: function PathExpression(path) {\n\t    this.addDepth(path.depth);\n\t    this.opcode('getContext', path.depth);\n\n\t    var name \x3d path.parts[0],\n\t        scoped \x3d _AST2['default'].helpers.scopedId(path),\n\t        blockParamId \x3d !path.depth \x26\x26 !scoped \x26\x26 this.blockParamIndex(name);\n\n\t    if (blockParamId) {\n\t      this.opcode('lookupBlockParam', blockParamId, path.parts);\n\t    } else if (!name) {\n\t      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n\t      this.opcode('pushContext');\n\t    } else if (path.data) {\n\t      this.options.data \x3d true;\n\t      this.opcode('lookupData', path.depth, path.parts);\n\t    } else {\n\t      this.opcode('lookupOnContext', path.parts, path.falsy, scoped);\n\t    }\n\t  },\n\n\t  StringLiteral: function StringLiteral(string) {\n\t    this.opcode('pushString', string.value);\n\t  },\n\n\t  NumberLiteral: function NumberLiteral(number) {\n\t    this.opcode('pushLiteral', number.value);\n\t  },\n\n\t  BooleanLiteral: function BooleanLiteral(bool) {\n\t    this.opcode('pushLiteral', bool.value);\n\t  },\n\n\t  UndefinedLiteral: function UndefinedLiteral() {\n\t    this.opcode('pushLiteral', 'undefined');\n\t  },\n\n\t  NullLiteral: function NullLiteral() {\n\t    this.opcode('pushLiteral', 'null');\n\t  },\n\n\t  Hash: function Hash(hash) {\n\t    var pairs \x3d hash.pairs,\n\t        i \x3d 0,\n\t        l \x3d pairs.length;\n\n\t    this.opcode('pushHash');\n\n\t    for (; i \x3c l; i++) {\n\t      this.pushParam(pairs[i].value);\n\t    }\n\t    while (i--) {\n\t      this.opcode('assignToHash', pairs[i].key);\n\t    }\n\t    this.opcode('popHash');\n\t  },\n\n\t  // HELPERS\n\t  opcode: function opcode(name) {\n\t    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });\n\t  },\n\n\t  addDepth: function addDepth(depth) {\n\t    if (!depth) {\n\t      return;\n\t    }\n\n\t    this.useDepths \x3d true;\n\t  },\n\n\t  classifySexpr: function classifySexpr(sexpr) {\n\t    var isSimple \x3d _AST2['default'].helpers.simpleId(sexpr.path);\n\n\t    var isBlockParam \x3d isSimple \x26\x26 !!this.blockParamIndex(sexpr.path.parts[0]);\n\n\t    // a mustache is an eligible helper if:\n\t    // * its id is simple (a single part, not `this` or `..`)\n\t    var isHelper \x3d !isBlockParam \x26\x26 _AST2['default'].helpers.helperExpression(sexpr);\n\n\t    // if a mustache is an eligible helper but not a definite\n\t    // helper, it is ambiguous, and will be resolved in a later\n\t    // pass or at runtime.\n\t    var isEligible \x3d !isBlockParam \x26\x26 (isHelper || isSimple);\n\n\t    // if ambiguous, we can possibly resolve the ambiguity now\n\t    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n\t    if (isEligible \x26\x26 !isHelper) {\n\t      var _name2 \x3d sexpr.path.parts[0],\n\t          options \x3d this.options;\n\n\t      if (options.knownHelpers[_name2]) {\n\t        isHelper \x3d true;\n\t      } else if (options.knownHelpersOnly) {\n\t        isEligible \x3d false;\n\t      }\n\t    }\n\n\t    if (isHelper) {\n\t      return 'helper';\n\t    } else if (isEligible) {\n\t      return 'ambiguous';\n\t    } else {\n\t      return 'simple';\n\t    }\n\t  },\n\n\t  pushParams: function pushParams(params) {\n\t    for (var i \x3d 0, l \x3d params.length; i \x3c l; i++) {\n\t      this.pushParam(params[i]);\n\t    }\n\t  },\n\n\t  pushParam: function pushParam(val) {\n\t    var value \x3d val.value !\x3d null ? val.value : val.original || '';\n\n\t    if (this.stringParams) {\n\t      if (value.replace) {\n\t        value \x3d value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n\t      }\n\n\t      if (val.depth) {\n\t        this.addDepth(val.depth);\n\t      }\n\t      this.opcode('getContext', val.depth || 0);\n\t      this.opcode('pushStringParam', value, val.type);\n\n\t      if (val.type \x3d\x3d\x3d 'SubExpression') {\n\t        // SubExpressions get evaluated and passed in\n\t        // in string params mode.\n\t        this.accept(val);\n\t      }\n\t    } else {\n\t      if (this.trackIds) {\n\t        var blockParamIndex \x3d undefined;\n\t        if (val.parts \x26\x26 !_AST2['default'].helpers.scopedId(val) \x26\x26 !val.depth) {\n\t          blockParamIndex \x3d this.blockParamIndex(val.parts[0]);\n\t        }\n\t        if (blockParamIndex) {\n\t          var blockParamChild \x3d val.parts.slice(1).join('.');\n\t          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n\t        } else {\n\t          value \x3d val.original || value;\n\t          if (value.replace) {\n\t            value \x3d value.replace(/^\\.\\//g, '').replace(/^\\.$/g, '');\n\t          }\n\n\t          this.opcode('pushId', val.type, value);\n\t        }\n\t      }\n\t      this.accept(val);\n\t    }\n\t  },\n\n\t  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n\t    var params \x3d sexpr.params;\n\t    this.pushParams(params);\n\n\t    this.opcode('pushProgram', program);\n\t    this.opcode('pushProgram', inverse);\n\n\t    if (sexpr.hash) {\n\t      this.accept(sexpr.hash);\n\t    } else {\n\t      this.opcode('emptyHash', omitEmpty);\n\t    }\n\n\t    return params;\n\t  },\n\n\t  blockParamIndex: function blockParamIndex(name) {\n\t    for (var depth \x3d 0, len \x3d this.options.blockParams.length; depth \x3c len; depth++) {\n\t      var blockParams \x3d this.options.blockParams[depth],\n\t          param \x3d blockParams \x26\x26 _isArray$indexOf.indexOf(blockParams, name);\n\t      if (blockParams \x26\x26 param \x3e\x3d 0) {\n\t        return [depth, param];\n\t      }\n\t    }\n\t  }\n\t};\n\n\tfunction precompile(input, options, env) {\n\t  if (input \x3d\x3d null || typeof input !\x3d\x3d 'string' \x26\x26 input.type !\x3d\x3d 'Program') {\n\t    throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n\t  }\n\n\t  options \x3d options || {};\n\t  if (!('data' in options)) {\n\t    options.data \x3d true;\n\t  }\n\t  if (options.compat) {\n\t    options.useDepths \x3d true;\n\t  }\n\n\t  var ast \x3d env.parse(input, options),\n\t      environment \x3d new env.Compiler().compile(ast, options);\n\t  return new env.JavaScriptCompiler().compile(environment, options);\n\t}\n\n\tfunction compile(input, _x, env) {\n\t  var options \x3d arguments[1] \x3d\x3d\x3d undefined ? {} : arguments[1];\n\n\t  if (input \x3d\x3d null || typeof input !\x3d\x3d 'string' \x26\x26 input.type !\x3d\x3d 'Program') {\n\t    throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n\t  }\n\n\t  if (!('data' in options)) {\n\t    options.data \x3d true;\n\t  }\n\t  if (options.compat) {\n\t    options.useDepths \x3d true;\n\t  }\n\n\t  var compiled \x3d undefined;\n\n\t  function compileInput() {\n\t    var ast \x3d env.parse(input, options),\n\t        environment \x3d new env.Compiler().compile(ast, options),\n\t        templateSpec \x3d new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n\t    return env.template(templateSpec);\n\t  }\n\n\t  // Template is only compiled on first use and cached after that point.\n\t  function ret(context, execOptions) {\n\t    if (!compiled) {\n\t      compiled \x3d compileInput();\n\t    }\n\t    return compiled.call(this, context, execOptions);\n\t  }\n\t  ret._setup \x3d function (setupOptions) {\n\t    if (!compiled) {\n\t      compiled \x3d compileInput();\n\t    }\n\t    return compiled._setup(setupOptions);\n\t  };\n\t  ret._child \x3d function (i, data, blockParams, depths) {\n\t    if (!compiled) {\n\t      compiled \x3d compileInput();\n\t    }\n\t    return compiled._child(i, data, blockParams, depths);\n\t  };\n\t  return ret;\n\t}\n\n\tfunction argEquals(a, b) {\n\t  if (a \x3d\x3d\x3d b) {\n\t    return true;\n\t  }\n\n\t  if (_isArray$indexOf.isArray(a) \x26\x26 _isArray$indexOf.isArray(b) \x26\x26 a.length \x3d\x3d\x3d b.length) {\n\t    for (var i \x3d 0; i \x3c a.length; i++) {\n\t      if (!argEquals(a[i], b[i])) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t}\n\n\tfunction transformLiteralToPath(sexpr) {\n\t  if (!sexpr.path.parts) {\n\t    var literal \x3d sexpr.path;\n\t    // Casting to string here to make false and 0 literal values play nicely with the rest\n\t    // of the system.\n\t    sexpr.path \x3d new _AST2['default'].PathExpression(false, 0, [literal.original + ''], literal.original + '', literal.loc);\n\t  }\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\n\tvar _COMPILER_REVISION$REVISION_CHANGES \x3d __webpack_require__(10);\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar _isArray \x3d __webpack_require__(13);\n\n\tvar _CodeGen \x3d __webpack_require__(18);\n\n\tvar _CodeGen2 \x3d _interopRequireDefault(_CodeGen);\n\n\tfunction Literal(value) {\n\t  this.value \x3d value;\n\t}\n\n\tfunction JavaScriptCompiler() {}\n\n\tJavaScriptCompiler.prototype \x3d {\n\t  // PUBLIC API: You can override these methods in a subclass to provide\n\t  // alternative compiled forms for name lookup and buffering semantics\n\t  nameLookup: function nameLookup(parent, name /* , type*/) {\n\t    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {\n\t      return [parent, '.', name];\n\t    } else {\n\t      return [parent, '[\\'', name, '\\']'];\n\t    }\n\t  },\n\t  depthedLookup: function depthedLookup(name) {\n\t    return [this.aliasable('this.lookup'), '(depths, \"', name, '\")'];\n\t  },\n\n\t  compilerInfo: function compilerInfo() {\n\t    var revision \x3d _COMPILER_REVISION$REVISION_CHANGES.COMPILER_REVISION,\n\t        versions \x3d _COMPILER_REVISION$REVISION_CHANGES.REVISION_CHANGES[revision];\n\t    return [revision, versions];\n\t  },\n\n\t  appendToBuffer: function appendToBuffer(source, location, explicit) {\n\t    // Force a source as this simplifies the merge logic.\n\t    if (!_isArray.isArray(source)) {\n\t      source \x3d [source];\n\t    }\n\t    source \x3d this.source.wrap(source, location);\n\n\t    if (this.environment.isSimple) {\n\t      return ['return ', source, ';'];\n\t    } else if (explicit) {\n\t      // This is a case where the buffer operation occurs as a child of another\n\t      // construct, generally braces. We have to explicitly output these buffer\n\t      // operations to ensure that the emitted code goes in the correct location.\n\t      return ['buffer +\x3d ', source, ';'];\n\t    } else {\n\t      source.appendToBuffer \x3d true;\n\t      return source;\n\t    }\n\t  },\n\n\t  initializeBuffer: function initializeBuffer() {\n\t    return this.quotedString('');\n\t  },\n\t  // END PUBLIC API\n\n\t  compile: function compile(environment, options, context, asObject) {\n\t    this.environment \x3d environment;\n\t    this.options \x3d options;\n\t    this.stringParams \x3d this.options.stringParams;\n\t    this.trackIds \x3d this.options.trackIds;\n\t    this.precompile \x3d !asObject;\n\n\t    this.name \x3d this.environment.name;\n\t    this.isChild \x3d !!context;\n\t    this.context \x3d context || {\n\t      programs: [],\n\t      environments: []\n\t    };\n\n\t    this.preamble();\n\n\t    this.stackSlot \x3d 0;\n\t    this.stackVars \x3d [];\n\t    this.aliases \x3d {};\n\t    this.registers \x3d { list: [] };\n\t    this.hashes \x3d [];\n\t    this.compileStack \x3d [];\n\t    this.inlineStack \x3d [];\n\t    this.blockParams \x3d [];\n\n\t    this.compileChildren(environment, options);\n\n\t    this.useDepths \x3d this.useDepths || environment.useDepths || this.options.compat;\n\t    this.useBlockParams \x3d this.useBlockParams || environment.useBlockParams;\n\n\t    var opcodes \x3d environment.opcodes,\n\t        opcode \x3d undefined,\n\t        firstLoc \x3d undefined,\n\t        i \x3d undefined,\n\t        l \x3d undefined;\n\n\t    for (i \x3d 0, l \x3d opcodes.length; i \x3c l; i++) {\n\t      opcode \x3d opcodes[i];\n\n\t      this.source.currentLocation \x3d opcode.loc;\n\t      firstLoc \x3d firstLoc || opcode.loc;\n\t      this[opcode.opcode].apply(this, opcode.args);\n\t    }\n\n\t    // Flush any trailing content that might be pending.\n\t    this.source.currentLocation \x3d firstLoc;\n\t    this.pushSource('');\n\n\t    /* istanbul ignore next */\n\t    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n\t      throw new _Exception2['default']('Compile completed with content left on stack');\n\t    }\n\n\t    var fn \x3d this.createFunctionContext(asObject);\n\t    if (!this.isChild) {\n\t      var ret \x3d {\n\t        compiler: this.compilerInfo(),\n\t        main: fn\n\t      };\n\t      var programs \x3d this.context.programs;\n\t      for (i \x3d 0, l \x3d programs.length; i \x3c l; i++) {\n\t        if (programs[i]) {\n\t          ret[i] \x3d programs[i];\n\t        }\n\t      }\n\n\t      if (this.environment.usePartial) {\n\t        ret.usePartial \x3d true;\n\t      }\n\t      if (this.options.data) {\n\t        ret.useData \x3d true;\n\t      }\n\t      if (this.useDepths) {\n\t        ret.useDepths \x3d true;\n\t      }\n\t      if (this.useBlockParams) {\n\t        ret.useBlockParams \x3d true;\n\t      }\n\t      if (this.options.compat) {\n\t        ret.compat \x3d true;\n\t      }\n\n\t      if (!asObject) {\n\t        ret.compiler \x3d JSON.stringify(ret.compiler);\n\n\t        this.source.currentLocation \x3d { start: { line: 1, column: 0 } };\n\t        ret \x3d this.objectLiteral(ret);\n\n\t        if (options.srcName) {\n\t          ret \x3d ret.toStringWithSourceMap({ file: options.destName });\n\t          ret.map \x3d ret.map \x26\x26 ret.map.toString();\n\t        } else {\n\t          ret \x3d ret.toString();\n\t        }\n\t      } else {\n\t        ret.compilerOptions \x3d this.options;\n\t      }\n\n\t      return ret;\n\t    } else {\n\t      return fn;\n\t    }\n\t  },\n\n\t  preamble: function preamble() {\n\t    // track the last context pushed into place to allow skipping the\n\t    // getContext opcode when it would be a noop\n\t    this.lastContext \x3d 0;\n\t    this.source \x3d new _CodeGen2['default'](this.options.srcName);\n\t  },\n\n\t  createFunctionContext: function createFunctionContext(asObject) {\n\t    var varDeclarations \x3d '';\n\n\t    var locals \x3d this.stackVars.concat(this.registers.list);\n\t    if (locals.length \x3e 0) {\n\t      varDeclarations +\x3d ', ' + locals.join(', ');\n\t    }\n\n\t    // Generate minimizer alias mappings\n\t    //\n\t    // When using true SourceNodes, this will update all references to the given alias\n\t    // as the source nodes are reused in situ. For the non-source node compilation mode,\n\t    // aliases will not be used, but this case is already being run on the client and\n\t    // we aren't concern about minimizing the template size.\n\t    var aliasCount \x3d 0;\n\t    for (var alias in this.aliases) {\n\t      // eslint-disable-line guard-for-in\n\t      var node \x3d this.aliases[alias];\n\n\t      if (this.aliases.hasOwnProperty(alias) \x26\x26 node.children \x26\x26 node.referenceCount \x3e 1) {\n\t        varDeclarations +\x3d ', alias' + ++aliasCount + '\x3d' + alias;\n\t        node.children[0] \x3d 'alias' + aliasCount;\n\t      }\n\t    }\n\n\t    var params \x3d ['depth0', 'helpers', 'partials', 'data'];\n\n\t    if (this.useBlockParams || this.useDepths) {\n\t      params.push('blockParams');\n\t    }\n\t    if (this.useDepths) {\n\t      params.push('depths');\n\t    }\n\n\t    // Perform a second pass over the output to merge content when possible\n\t    var source \x3d this.mergeSource(varDeclarations);\n\n\t    if (asObject) {\n\t      params.push(source);\n\n\t      return Function.apply(this, params);\n\t    } else {\n\t      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n\t    }\n\t  },\n\t  mergeSource: function mergeSource(varDeclarations) {\n\t    var isSimple \x3d this.environment.isSimple,\n\t        appendOnly \x3d !this.forceBuffer,\n\t        appendFirst \x3d undefined,\n\t        sourceSeen \x3d undefined,\n\t        bufferStart \x3d undefined,\n\t        bufferEnd \x3d undefined;\n\t    this.source.each(function (line) {\n\t      if (line.appendToBuffer) {\n\t        if (bufferStart) {\n\t          line.prepend('  + ');\n\t        } else {\n\t          bufferStart \x3d line;\n\t        }\n\t        bufferEnd \x3d line;\n\t      } else {\n\t        if (bufferStart) {\n\t          if (!sourceSeen) {\n\t            appendFirst \x3d true;\n\t          } else {\n\t            bufferStart.prepend('buffer +\x3d ');\n\t          }\n\t          bufferEnd.add(';');\n\t          bufferStart \x3d bufferEnd \x3d undefined;\n\t        }\n\n\t        sourceSeen \x3d true;\n\t        if (!isSimple) {\n\t          appendOnly \x3d false;\n\t        }\n\t      }\n\t    });\n\n\t    if (appendOnly) {\n\t      if (bufferStart) {\n\t        bufferStart.prepend('return ');\n\t        bufferEnd.add(';');\n\t      } else if (!sourceSeen) {\n\t        this.source.push('return \"\";');\n\t      }\n\t    } else {\n\t      varDeclarations +\x3d ', buffer \x3d ' + (appendFirst ? '' : this.initializeBuffer());\n\n\t      if (bufferStart) {\n\t        bufferStart.prepend('return buffer + ');\n\t        bufferEnd.add(';');\n\t      } else {\n\t        this.source.push('return buffer;');\n\t      }\n\t    }\n\n\t    if (varDeclarations) {\n\t      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n\t    }\n\n\t    return this.source.merge();\n\t  },\n\n\t  // [blockValue]\n\t  //\n\t  // On stack, before: hash, inverse, program, value\n\t  // On stack, after: return value of blockHelperMissing\n\t  //\n\t  // The purpose of this opcode is to take a block of the form\n\t  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n\t  // replace it on the stack with the result of properly\n\t  // invoking blockHelperMissing.\n\t  blockValue: function blockValue(name) {\n\t    var blockHelperMissing \x3d this.aliasable('helpers.blockHelperMissing'),\n\t        params \x3d [this.contextName(0)];\n\t    this.setupHelperArgs(name, 0, params);\n\n\t    var blockName \x3d this.popStack();\n\t    params.splice(1, 0, blockName);\n\n\t    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n\t  },\n\n\t  // [ambiguousBlockValue]\n\t  //\n\t  // On stack, before: hash, inverse, program, value\n\t  // Compiler value, before: lastHelper\x3dvalue of last found helper, if any\n\t  // On stack, after, if no lastHelper: same as [blockValue]\n\t  // On stack, after, if lastHelper: value\n\t  ambiguousBlockValue: function ambiguousBlockValue() {\n\t    // We're being a bit cheeky and reusing the options value from the prior exec\n\t    var blockHelperMissing \x3d this.aliasable('helpers.blockHelperMissing'),\n\t        params \x3d [this.contextName(0)];\n\t    this.setupHelperArgs('', 0, params, true);\n\n\t    this.flushInline();\n\n\t    var current \x3d this.topStack();\n\t    params.splice(1, 0, current);\n\n\t    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' \x3d ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n\t  },\n\n\t  // [appendContent]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: ...\n\t  //\n\t  // Appends the string value of `content` to the current buffer\n\t  appendContent: function appendContent(content) {\n\t    if (this.pendingContent) {\n\t      content \x3d this.pendingContent + content;\n\t    } else {\n\t      this.pendingLocation \x3d this.source.currentLocation;\n\t    }\n\n\t    this.pendingContent \x3d content;\n\t  },\n\n\t  // [append]\n\t  //\n\t  // On stack, before: value, ...\n\t  // On stack, after: ...\n\t  //\n\t  // Coerces `value` to a String and appends it to the current buffer.\n\t  //\n\t  // If `value` is truthy, or 0, it is coerced into a string and appended\n\t  // Otherwise, the empty string is appended\n\t  append: function append() {\n\t    if (this.isInline()) {\n\t      this.replaceStack(function (current) {\n\t        return [' !\x3d null ? ', current, ' : \"\"'];\n\t      });\n\n\t      this.pushSource(this.appendToBuffer(this.popStack()));\n\t    } else {\n\t      var local \x3d this.popStack();\n\t      this.pushSource(['if (', local, ' !\x3d null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n\t      if (this.environment.isSimple) {\n\t        this.pushSource(['else { ', this.appendToBuffer('\\'\\'', undefined, true), ' }']);\n\t      }\n\t    }\n\t  },\n\n\t  // [appendEscaped]\n\t  //\n\t  // On stack, before: value, ...\n\t  // On stack, after: ...\n\t  //\n\t  // Escape `value` and append it to the buffer\n\t  appendEscaped: function appendEscaped() {\n\t    this.pushSource(this.appendToBuffer([this.aliasable('this.escapeExpression'), '(', this.popStack(), ')']));\n\t  },\n\n\t  // [getContext]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: ...\n\t  // Compiler value, after: lastContext\x3ddepth\n\t  //\n\t  // Set the value of the `lastContext` compiler value to the depth\n\t  getContext: function getContext(depth) {\n\t    this.lastContext \x3d depth;\n\t  },\n\n\t  // [pushContext]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: currentContext, ...\n\t  //\n\t  // Pushes the value of the current context onto the stack.\n\t  pushContext: function pushContext() {\n\t    this.pushStackLiteral(this.contextName(this.lastContext));\n\t  },\n\n\t  // [lookupOnContext]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: currentContext[name], ...\n\t  //\n\t  // Looks up the value of `name` on the current context and pushes\n\t  // it onto the stack.\n\t  lookupOnContext: function lookupOnContext(parts, falsy, scoped) {\n\t    var i \x3d 0;\n\n\t    if (!scoped \x26\x26 this.options.compat \x26\x26 !this.lastContext) {\n\t      // The depthed query is expected to handle the undefined logic for the root level that\n\t      // is implemented below, so we evaluate that directly in compat mode\n\t      this.push(this.depthedLookup(parts[i++]));\n\t    } else {\n\t      this.pushContext();\n\t    }\n\n\t    this.resolvePath('context', parts, i, falsy);\n\t  },\n\n\t  // [lookupBlockParam]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: blockParam[name], ...\n\t  //\n\t  // Looks up the value of `parts` on the given block param and pushes\n\t  // it onto the stack.\n\t  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n\t    this.useBlockParams \x3d true;\n\n\t    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n\t    this.resolvePath('context', parts, 1);\n\t  },\n\n\t  // [lookupData]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: data, ...\n\t  //\n\t  // Push the data lookup operator\n\t  lookupData: function lookupData(depth, parts) {\n\t    if (!depth) {\n\t      this.pushStackLiteral('data');\n\t    } else {\n\t      this.pushStackLiteral('this.data(data, ' + depth + ')');\n\t    }\n\n\t    this.resolvePath('data', parts, 0, true);\n\t  },\n\n\t  resolvePath: function resolvePath(type, parts, i, falsy) {\n\t    var _this \x3d this;\n\n\t    if (this.options.strict || this.options.assumeObjects) {\n\t      this.push(strictLookup(this.options.strict, this, parts, type));\n\t      return;\n\t    }\n\n\t    var len \x3d parts.length;\n\t    for (; i \x3c len; i++) {\n\t      /*eslint-disable no-loop-func */\n\t      this.replaceStack(function (current) {\n\t        var lookup \x3d _this.nameLookup(current, parts[i], type);\n\t        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n\t        // needs to have the special handling for these values.\n\t        if (!falsy) {\n\t          return [' !\x3d null ? ', lookup, ' : ', current];\n\t        } else {\n\t          // Otherwise we can use generic falsy handling\n\t          return [' \x26\x26 ', lookup];\n\t        }\n\t      });\n\t      /*eslint-enable no-loop-func */\n\t    }\n\t  },\n\n\t  // [resolvePossibleLambda]\n\t  //\n\t  // On stack, before: value, ...\n\t  // On stack, after: resolved value, ...\n\t  //\n\t  // If the `value` is a lambda, replace it on the stack by\n\t  // the return value of the lambda\n\t  resolvePossibleLambda: function resolvePossibleLambda() {\n\t    this.push([this.aliasable('this.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n\t  },\n\n\t  // [pushStringParam]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: string, currentContext, ...\n\t  //\n\t  // This opcode is designed for use in string mode, which\n\t  // provides the string value of a parameter along with its\n\t  // depth rather than resolving it immediately.\n\t  pushStringParam: function pushStringParam(string, type) {\n\t    this.pushContext();\n\t    this.pushString(type);\n\n\t    // If it's a subexpression, the string result\n\t    // will be pushed after this opcode.\n\t    if (type !\x3d\x3d 'SubExpression') {\n\t      if (typeof string \x3d\x3d\x3d 'string') {\n\t        this.pushString(string);\n\t      } else {\n\t        this.pushStackLiteral(string);\n\t      }\n\t    }\n\t  },\n\n\t  emptyHash: function emptyHash(omitEmpty) {\n\t    if (this.trackIds) {\n\t      this.push('{}'); // hashIds\n\t    }\n\t    if (this.stringParams) {\n\t      this.push('{}'); // hashContexts\n\t      this.push('{}'); // hashTypes\n\t    }\n\t    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n\t  },\n\t  pushHash: function pushHash() {\n\t    if (this.hash) {\n\t      this.hashes.push(this.hash);\n\t    }\n\t    this.hash \x3d { values: [], types: [], contexts: [], ids: [] };\n\t  },\n\t  popHash: function popHash() {\n\t    var hash \x3d this.hash;\n\t    this.hash \x3d this.hashes.pop();\n\n\t    if (this.trackIds) {\n\t      this.push(this.objectLiteral(hash.ids));\n\t    }\n\t    if (this.stringParams) {\n\t      this.push(this.objectLiteral(hash.contexts));\n\t      this.push(this.objectLiteral(hash.types));\n\t    }\n\n\t    this.push(this.objectLiteral(hash.values));\n\t  },\n\n\t  // [pushString]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: quotedString(string), ...\n\t  //\n\t  // Push a quoted version of `string` onto the stack\n\t  pushString: function pushString(string) {\n\t    this.pushStackLiteral(this.quotedString(string));\n\t  },\n\n\t  // [pushLiteral]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: value, ...\n\t  //\n\t  // Pushes a value onto the stack. This operation prevents\n\t  // the compiler from creating a temporary variable to hold\n\t  // it.\n\t  pushLiteral: function pushLiteral(value) {\n\t    this.pushStackLiteral(value);\n\t  },\n\n\t  // [pushProgram]\n\t  //\n\t  // On stack, before: ...\n\t  // On stack, after: program(guid), ...\n\t  //\n\t  // Push a program expression onto the stack. This takes\n\t  // a compile-time guid and converts it into a runtime-accessible\n\t  // expression.\n\t  pushProgram: function pushProgram(guid) {\n\t    if (guid !\x3d null) {\n\t      this.pushStackLiteral(this.programExpression(guid));\n\t    } else {\n\t      this.pushStackLiteral(null);\n\t    }\n\t  },\n\n\t  // [invokeHelper]\n\t  //\n\t  // On stack, before: hash, inverse, program, params..., ...\n\t  // On stack, after: result of helper invocation\n\t  //\n\t  // Pops off the helper's parameters, invokes the helper,\n\t  // and pushes the helper's return value onto the stack.\n\t  //\n\t  // If the helper is not found, `helperMissing` is called.\n\t  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n\t    var nonHelper \x3d this.popStack(),\n\t        helper \x3d this.setupHelper(paramSize, name),\n\t        simple \x3d isSimple ? [helper.name, ' || '] : '';\n\n\t    var lookup \x3d ['('].concat(simple, nonHelper);\n\t    if (!this.options.strict) {\n\t      lookup.push(' || ', this.aliasable('helpers.helperMissing'));\n\t    }\n\t    lookup.push(')');\n\n\t    this.push(this.source.functionCall(lookup, 'call', helper.callParams));\n\t  },\n\n\t  // [invokeKnownHelper]\n\t  //\n\t  // On stack, before: hash, inverse, program, params..., ...\n\t  // On stack, after: result of helper invocation\n\t  //\n\t  // This operation is used when the helper is known to exist,\n\t  // so a `helperMissing` fallback is not required.\n\t  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n\t    var helper \x3d this.setupHelper(paramSize, name);\n\t    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n\t  },\n\n\t  // [invokeAmbiguous]\n\t  //\n\t  // On stack, before: hash, inverse, program, params..., ...\n\t  // On stack, after: result of disambiguation\n\t  //\n\t  // This operation is used when an expression like `{{foo}}`\n\t  // is provided, but we don't know at compile-time whether it\n\t  // is a helper or a path.\n\t  //\n\t  // This operation emits more code than the other options,\n\t  // and can be avoided by passing the `knownHelpers` and\n\t  // `knownHelpersOnly` flags at compile-time.\n\t  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n\t    this.useRegister('helper');\n\n\t    var nonHelper \x3d this.popStack();\n\n\t    this.emptyHash();\n\t    var helper \x3d this.setupHelper(0, name, helperCall);\n\n\t    var helperName \x3d this.lastHelper \x3d this.nameLookup('helpers', name, 'helper');\n\n\t    var lookup \x3d ['(', '(helper \x3d ', helperName, ' || ', nonHelper, ')'];\n\t    if (!this.options.strict) {\n\t      lookup[0] \x3d '(helper \x3d ';\n\t      lookup.push(' !\x3d null ? helper : ', this.aliasable('helpers.helperMissing'));\n\t    }\n\n\t    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper \x3d\x3d\x3d ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n\t  },\n\n\t  // [invokePartial]\n\t  //\n\t  // On stack, before: context, ...\n\t  // On stack after: result of partial invocation\n\t  //\n\t  // This operation pops off a context, invokes a partial with that context,\n\t  // and pushes the result of the invocation back.\n\t  invokePartial: function invokePartial(isDynamic, name, indent) {\n\t    var params \x3d [],\n\t        options \x3d this.setupParams(name, 1, params, false);\n\n\t    if (isDynamic) {\n\t      name \x3d this.popStack();\n\t      delete options.name;\n\t    }\n\n\t    if (indent) {\n\t      options.indent \x3d JSON.stringify(indent);\n\t    }\n\t    options.helpers \x3d 'helpers';\n\t    options.partials \x3d 'partials';\n\n\t    if (!isDynamic) {\n\t      params.unshift(this.nameLookup('partials', name, 'partial'));\n\t    } else {\n\t      params.unshift(name);\n\t    }\n\n\t    if (this.options.compat) {\n\t      options.depths \x3d 'depths';\n\t    }\n\t    options \x3d this.objectLiteral(options);\n\t    params.push(options);\n\n\t    this.push(this.source.functionCall('this.invokePartial', '', params));\n\t  },\n\n\t  // [assignToHash]\n\t  //\n\t  // On stack, before: value, ..., hash, ...\n\t  // On stack, after: ..., hash, ...\n\t  //\n\t  // Pops a value off the stack and assigns it to the current hash\n\t  assignToHash: function assignToHash(key) {\n\t    var value \x3d this.popStack(),\n\t        context \x3d undefined,\n\t        type \x3d undefined,\n\t        id \x3d undefined;\n\n\t    if (this.trackIds) {\n\t      id \x3d this.popStack();\n\t    }\n\t    if (this.stringParams) {\n\t      type \x3d this.popStack();\n\t      context \x3d this.popStack();\n\t    }\n\n\t    var hash \x3d this.hash;\n\t    if (context) {\n\t      hash.contexts[key] \x3d context;\n\t    }\n\t    if (type) {\n\t      hash.types[key] \x3d type;\n\t    }\n\t    if (id) {\n\t      hash.ids[key] \x3d id;\n\t    }\n\t    hash.values[key] \x3d value;\n\t  },\n\n\t  pushId: function pushId(type, name, child) {\n\t    if (type \x3d\x3d\x3d 'BlockParam') {\n\t      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n\t    } else if (type \x3d\x3d\x3d 'PathExpression') {\n\t      this.pushString(name);\n\t    } else if (type \x3d\x3d\x3d 'SubExpression') {\n\t      this.pushStackLiteral('true');\n\t    } else {\n\t      this.pushStackLiteral('null');\n\t    }\n\t  },\n\n\t  // HELPERS\n\n\t  compiler: JavaScriptCompiler,\n\n\t  compileChildren: function compileChildren(environment, options) {\n\t    var children \x3d environment.children,\n\t        child \x3d undefined,\n\t        compiler \x3d undefined;\n\n\t    for (var i \x3d 0, l \x3d children.length; i \x3c l; i++) {\n\t      child \x3d children[i];\n\t      compiler \x3d new this.compiler(); // eslint-disable-line new-cap\n\n\t      var index \x3d this.matchExistingProgram(child);\n\n\t      if (index \x3d\x3d null) {\n\t        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n\t        index \x3d this.context.programs.length;\n\t        child.index \x3d index;\n\t        child.name \x3d 'program' + index;\n\t        this.context.programs[index] \x3d compiler.compile(child, options, this.context, !this.precompile);\n\t        this.context.environments[index] \x3d child;\n\n\t        this.useDepths \x3d this.useDepths || compiler.useDepths;\n\t        this.useBlockParams \x3d this.useBlockParams || compiler.useBlockParams;\n\t      } else {\n\t        child.index \x3d index;\n\t        child.name \x3d 'program' + index;\n\n\t        this.useDepths \x3d this.useDepths || child.useDepths;\n\t        this.useBlockParams \x3d this.useBlockParams || child.useBlockParams;\n\t      }\n\t    }\n\t  },\n\t  matchExistingProgram: function matchExistingProgram(child) {\n\t    for (var i \x3d 0, len \x3d this.context.environments.length; i \x3c len; i++) {\n\t      var environment \x3d this.context.environments[i];\n\t      if (environment \x26\x26 environment.equals(child)) {\n\t        return i;\n\t      }\n\t    }\n\t  },\n\n\t  programExpression: function programExpression(guid) {\n\t    var child \x3d this.environment.children[guid],\n\t        programParams \x3d [child.index, 'data', child.blockParams];\n\n\t    if (this.useBlockParams || this.useDepths) {\n\t      programParams.push('blockParams');\n\t    }\n\t    if (this.useDepths) {\n\t      programParams.push('depths');\n\t    }\n\n\t    return 'this.program(' + programParams.join(', ') + ')';\n\t  },\n\n\t  useRegister: function useRegister(name) {\n\t    if (!this.registers[name]) {\n\t      this.registers[name] \x3d true;\n\t      this.registers.list.push(name);\n\t    }\n\t  },\n\n\t  push: function push(expr) {\n\t    if (!(expr instanceof Literal)) {\n\t      expr \x3d this.source.wrap(expr);\n\t    }\n\n\t    this.inlineStack.push(expr);\n\t    return expr;\n\t  },\n\n\t  pushStackLiteral: function pushStackLiteral(item) {\n\t    this.push(new Literal(item));\n\t  },\n\n\t  pushSource: function pushSource(source) {\n\t    if (this.pendingContent) {\n\t      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n\t      this.pendingContent \x3d undefined;\n\t    }\n\n\t    if (source) {\n\t      this.source.push(source);\n\t    }\n\t  },\n\n\t  replaceStack: function replaceStack(callback) {\n\t    var prefix \x3d ['('],\n\t        stack \x3d undefined,\n\t        createdStack \x3d undefined,\n\t        usedLiteral \x3d undefined;\n\n\t    /* istanbul ignore next */\n\t    if (!this.isInline()) {\n\t      throw new _Exception2['default']('replaceStack on non-inline');\n\t    }\n\n\t    // We want to merge the inline statement into the replacement statement via ','\n\t    var top \x3d this.popStack(true);\n\n\t    if (top instanceof Literal) {\n\t      // Literals do not need to be inlined\n\t      stack \x3d [top.value];\n\t      prefix \x3d ['(', stack];\n\t      usedLiteral \x3d true;\n\t    } else {\n\t      // Get or create the current stack name for use by the inline\n\t      createdStack \x3d true;\n\t      var _name \x3d this.incrStack();\n\n\t      prefix \x3d ['((', this.push(_name), ' \x3d ', top, ')'];\n\t      stack \x3d this.topStack();\n\t    }\n\n\t    var item \x3d callback.call(this, stack);\n\n\t    if (!usedLiteral) {\n\t      this.popStack();\n\t    }\n\t    if (createdStack) {\n\t      this.stackSlot--;\n\t    }\n\t    this.push(prefix.concat(item, ')'));\n\t  },\n\n\t  incrStack: function incrStack() {\n\t    this.stackSlot++;\n\t    if (this.stackSlot \x3e this.stackVars.length) {\n\t      this.stackVars.push('stack' + this.stackSlot);\n\t    }\n\t    return this.topStackName();\n\t  },\n\t  topStackName: function topStackName() {\n\t    return 'stack' + this.stackSlot;\n\t  },\n\t  flushInline: function flushInline() {\n\t    var inlineStack \x3d this.inlineStack;\n\t    this.inlineStack \x3d [];\n\t    for (var i \x3d 0, len \x3d inlineStack.length; i \x3c len; i++) {\n\t      var entry \x3d inlineStack[i];\n\t      /* istanbul ignore if */\n\t      if (entry instanceof Literal) {\n\t        this.compileStack.push(entry);\n\t      } else {\n\t        var stack \x3d this.incrStack();\n\t        this.pushSource([stack, ' \x3d ', entry, ';']);\n\t        this.compileStack.push(stack);\n\t      }\n\t    }\n\t  },\n\t  isInline: function isInline() {\n\t    return this.inlineStack.length;\n\t  },\n\n\t  popStack: function popStack(wrapped) {\n\t    var inline \x3d this.isInline(),\n\t        item \x3d (inline ? this.inlineStack : this.compileStack).pop();\n\n\t    if (!wrapped \x26\x26 item instanceof Literal) {\n\t      return item.value;\n\t    } else {\n\t      if (!inline) {\n\t        /* istanbul ignore next */\n\t        if (!this.stackSlot) {\n\t          throw new _Exception2['default']('Invalid stack pop');\n\t        }\n\t        this.stackSlot--;\n\t      }\n\t      return item;\n\t    }\n\t  },\n\n\t  topStack: function topStack() {\n\t    var stack \x3d this.isInline() ? this.inlineStack : this.compileStack,\n\t        item \x3d stack[stack.length - 1];\n\n\t    /* istanbul ignore if */\n\t    if (item instanceof Literal) {\n\t      return item.value;\n\t    } else {\n\t      return item;\n\t    }\n\t  },\n\n\t  contextName: function contextName(context) {\n\t    if (this.useDepths \x26\x26 context) {\n\t      return 'depths[' + context + ']';\n\t    } else {\n\t      return 'depth' + context;\n\t    }\n\t  },\n\n\t  quotedString: function quotedString(str) {\n\t    return this.source.quotedString(str);\n\t  },\n\n\t  objectLiteral: function objectLiteral(obj) {\n\t    return this.source.objectLiteral(obj);\n\t  },\n\n\t  aliasable: function aliasable(name) {\n\t    var ret \x3d this.aliases[name];\n\t    if (ret) {\n\t      ret.referenceCount++;\n\t      return ret;\n\t    }\n\n\t    ret \x3d this.aliases[name] \x3d this.source.wrap(name);\n\t    ret.aliasable \x3d true;\n\t    ret.referenceCount \x3d 1;\n\n\t    return ret;\n\t  },\n\n\t  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n\t    var params \x3d [],\n\t        paramsInit \x3d this.setupHelperArgs(name, paramSize, params, blockHelper);\n\t    var foundHelper \x3d this.nameLookup('helpers', name, 'helper');\n\n\t    return {\n\t      params: params,\n\t      paramsInit: paramsInit,\n\t      name: foundHelper,\n\t      callParams: [this.contextName(0)].concat(params)\n\t    };\n\t  },\n\n\t  setupParams: function setupParams(helper, paramSize, params) {\n\t    var options \x3d {},\n\t        contexts \x3d [],\n\t        types \x3d [],\n\t        ids \x3d [],\n\t        param \x3d undefined;\n\n\t    options.name \x3d this.quotedString(helper);\n\t    options.hash \x3d this.popStack();\n\n\t    if (this.trackIds) {\n\t      options.hashIds \x3d this.popStack();\n\t    }\n\t    if (this.stringParams) {\n\t      options.hashTypes \x3d this.popStack();\n\t      options.hashContexts \x3d this.popStack();\n\t    }\n\n\t    var inverse \x3d this.popStack(),\n\t        program \x3d this.popStack();\n\n\t    // Avoid setting fn and inverse if neither are set. This allows\n\t    // helpers to do a check for `if (options.fn)`\n\t    if (program || inverse) {\n\t      options.fn \x3d program || 'this.noop';\n\t      options.inverse \x3d inverse || 'this.noop';\n\t    }\n\n\t    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n\t    // so we need to pop them off the stack in reverse order\n\t    var i \x3d paramSize;\n\t    while (i--) {\n\t      param \x3d this.popStack();\n\t      params[i] \x3d param;\n\n\t      if (this.trackIds) {\n\t        ids[i] \x3d this.popStack();\n\t      }\n\t      if (this.stringParams) {\n\t        types[i] \x3d this.popStack();\n\t        contexts[i] \x3d this.popStack();\n\t      }\n\t    }\n\n\t    if (this.trackIds) {\n\t      options.ids \x3d this.source.generateArray(ids);\n\t    }\n\t    if (this.stringParams) {\n\t      options.types \x3d this.source.generateArray(types);\n\t      options.contexts \x3d this.source.generateArray(contexts);\n\t    }\n\n\t    if (this.options.data) {\n\t      options.data \x3d 'data';\n\t    }\n\t    if (this.useBlockParams) {\n\t      options.blockParams \x3d 'blockParams';\n\t    }\n\t    return options;\n\t  },\n\n\t  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n\t    var options \x3d this.setupParams(helper, paramSize, params, true);\n\t    options \x3d this.objectLiteral(options);\n\t    if (useRegister) {\n\t      this.useRegister('options');\n\t      params.push('options');\n\t      return ['options\x3d', options];\n\t    } else {\n\t      params.push(options);\n\t      return '';\n\t    }\n\t  }\n\t};\n\n\t(function () {\n\t  var reservedWords \x3d ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n\n\t  var compilerWords \x3d JavaScriptCompiler.RESERVED_WORDS \x3d {};\n\n\t  for (var i \x3d 0, l \x3d reservedWords.length; i \x3c l; i++) {\n\t    compilerWords[reservedWords[i]] \x3d true;\n\t  }\n\t})();\n\n\tJavaScriptCompiler.isValidJavaScriptVariableName \x3d function (name) {\n\t  return !JavaScriptCompiler.RESERVED_WORDS[name] \x26\x26 /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n\t};\n\n\tfunction strictLookup(requireTerminal, compiler, parts, type) {\n\t  var stack \x3d compiler.popStack(),\n\t      i \x3d 0,\n\t      len \x3d parts.length;\n\t  if (requireTerminal) {\n\t    len--;\n\t  }\n\n\t  for (; i \x3c len; i++) {\n\t    stack \x3d compiler.nameLookup(stack, parts[i], type);\n\t  }\n\n\t  if (requireTerminal) {\n\t    return [compiler.aliasable('this.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];\n\t  } else {\n\t    return stack;\n\t  }\n\t}\n\n\texports['default'] \x3d JavaScriptCompiler;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar _AST \x3d __webpack_require__(2);\n\n\tvar _AST2 \x3d _interopRequireDefault(_AST);\n\n\tfunction Visitor() {\n\t  this.parents \x3d [];\n\t}\n\n\tVisitor.prototype \x3d {\n\t  constructor: Visitor,\n\t  mutating: false,\n\n\t  // Visits a given value. If mutating, will replace the value if necessary.\n\t  acceptKey: function acceptKey(node, name) {\n\t    var value \x3d this.accept(node[name]);\n\t    if (this.mutating) {\n\t      // Hacky sanity check:\n\t      if (value \x26\x26 (!value.type || !_AST2['default'][value.type])) {\n\t        throw new _Exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n\t      }\n\t      node[name] \x3d value;\n\t    }\n\t  },\n\n\t  // Performs an accept operation with added sanity check to ensure\n\t  // required keys are not removed.\n\t  acceptRequired: function acceptRequired(node, name) {\n\t    this.acceptKey(node, name);\n\n\t    if (!node[name]) {\n\t      throw new _Exception2['default'](node.type + ' requires ' + name);\n\t    }\n\t  },\n\n\t  // Traverses a given array. If mutating, empty respnses will be removed\n\t  // for child elements.\n\t  acceptArray: function acceptArray(array) {\n\t    for (var i \x3d 0, l \x3d array.length; i \x3c l; i++) {\n\t      this.acceptKey(array, i);\n\n\t      if (!array[i]) {\n\t        array.splice(i, 1);\n\t        i--;\n\t        l--;\n\t      }\n\t    }\n\t  },\n\n\t  accept: function accept(object) {\n\t    if (!object) {\n\t      return;\n\t    }\n\n\t    if (this.current) {\n\t      this.parents.unshift(this.current);\n\t    }\n\t    this.current \x3d object;\n\n\t    var ret \x3d this[object.type](object);\n\n\t    this.current \x3d this.parents.shift();\n\n\t    if (!this.mutating || ret) {\n\t      return ret;\n\t    } else if (ret !\x3d\x3d false) {\n\t      return object;\n\t    }\n\t  },\n\n\t  Program: function Program(program) {\n\t    this.acceptArray(program.body);\n\t  },\n\n\t  MustacheStatement: function MustacheStatement(mustache) {\n\t    this.acceptRequired(mustache, 'path');\n\t    this.acceptArray(mustache.params);\n\t    this.acceptKey(mustache, 'hash');\n\t  },\n\n\t  BlockStatement: function BlockStatement(block) {\n\t    this.acceptRequired(block, 'path');\n\t    this.acceptArray(block.params);\n\t    this.acceptKey(block, 'hash');\n\n\t    this.acceptKey(block, 'program');\n\t    this.acceptKey(block, 'inverse');\n\t  },\n\n\t  PartialStatement: function PartialStatement(partial) {\n\t    this.acceptRequired(partial, 'name');\n\t    this.acceptArray(partial.params);\n\t    this.acceptKey(partial, 'hash');\n\t  },\n\n\t  ContentStatement: function ContentStatement() {},\n\t  CommentStatement: function CommentStatement() {},\n\n\t  SubExpression: function SubExpression(sexpr) {\n\t    this.acceptRequired(sexpr, 'path');\n\t    this.acceptArray(sexpr.params);\n\t    this.acceptKey(sexpr, 'hash');\n\t  },\n\n\t  PathExpression: function PathExpression() {},\n\n\t  StringLiteral: function StringLiteral() {},\n\t  NumberLiteral: function NumberLiteral() {},\n\t  BooleanLiteral: function BooleanLiteral() {},\n\t  UndefinedLiteral: function UndefinedLiteral() {},\n\t  NullLiteral: function NullLiteral() {},\n\n\t  Hash: function Hash(hash) {\n\t    this.acceptArray(hash.pairs);\n\t  },\n\t  HashPair: function HashPair(pair) {\n\t    this.acceptRequired(pair, 'value');\n\t  }\n\t};\n\n\texports['default'] \x3d Visitor;\n\tmodule.exports \x3d exports['default'];\n\t/* content */ /* comment */ /* path */ /* string */ /* number */ /* bool */ /* literal */ /* literal */\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\n\texports.__esModule \x3d true;\n\t/*global window */\n\n\texports['default'] \x3d function (Handlebars) {\n\t  /* istanbul ignore next */\n\t  var root \x3d typeof global !\x3d\x3d 'undefined' ? global : window,\n\t      $Handlebars \x3d root.Handlebars;\n\t  /* istanbul ignore next */\n\t  Handlebars.noConflict \x3d function () {\n\t    if (root.Handlebars \x3d\x3d\x3d Handlebars) {\n\t      root.Handlebars \x3d $Handlebars;\n\t    }\n\t  };\n\t};\n\n\tmodule.exports \x3d exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports[\"default\"] \x3d function (obj) {\n\t  return obj \x26\x26 obj.__esModule ? obj : {\n\t    \"default\": obj\n\t  };\n\t};\n\n\texports.__esModule \x3d true;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports[\"default\"] \x3d function (obj) {\n\t  if (obj \x26\x26 obj.__esModule) {\n\t    return obj;\n\t  } else {\n\t    var newObj \x3d {};\n\n\t    if (typeof obj \x3d\x3d\x3d \"object\" \x26\x26 obj !\x3d\x3d null) {\n\t      for (var key in obj) {\n\t        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] \x3d obj[key];\n\t      }\n\t    }\n\n\t    newObj[\"default\"] \x3d obj;\n\t    return newObj;\n\t  }\n\t};\n\n\texports.__esModule \x3d true;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireWildcard \x3d __webpack_require__(9)['default'];\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\texports.HandlebarsEnvironment \x3d HandlebarsEnvironment;\n\texports.createFrame \x3d createFrame;\n\n\tvar _import \x3d __webpack_require__(13);\n\n\tvar Utils \x3d _interopRequireWildcard(_import);\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar VERSION \x3d '3.0.1';\n\texports.VERSION \x3d VERSION;\n\tvar COMPILER_REVISION \x3d 6;\n\n\texports.COMPILER_REVISION \x3d COMPILER_REVISION;\n\tvar REVISION_CHANGES \x3d {\n\t  1: '\x3c\x3d 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n\t  2: '\x3d\x3d 1.0.0-rc.3',\n\t  3: '\x3d\x3d 1.0.0-rc.4',\n\t  4: '\x3d\x3d 1.x.x',\n\t  5: '\x3d\x3d 2.0.0-alpha.x',\n\t  6: '\x3e\x3d 2.0.0-beta.1'\n\t};\n\n\texports.REVISION_CHANGES \x3d REVISION_CHANGES;\n\tvar isArray \x3d Utils.isArray,\n\t    isFunction \x3d Utils.isFunction,\n\t    toString \x3d Utils.toString,\n\t    objectType \x3d '[object Object]';\n\n\tfunction HandlebarsEnvironment(helpers, partials) {\n\t  this.helpers \x3d helpers || {};\n\t  this.partials \x3d partials || {};\n\n\t  registerDefaultHelpers(this);\n\t}\n\n\tHandlebarsEnvironment.prototype \x3d {\n\t  constructor: HandlebarsEnvironment,\n\n\t  logger: logger,\n\t  log: log,\n\n\t  registerHelper: function registerHelper(name, fn) {\n\t    if (toString.call(name) \x3d\x3d\x3d objectType) {\n\t      if (fn) {\n\t        throw new _Exception2['default']('Arg not supported with multiple helpers');\n\t      }\n\t      Utils.extend(this.helpers, name);\n\t    } else {\n\t      this.helpers[name] \x3d fn;\n\t    }\n\t  },\n\t  unregisterHelper: function unregisterHelper(name) {\n\t    delete this.helpers[name];\n\t  },\n\n\t  registerPartial: function registerPartial(name, partial) {\n\t    if (toString.call(name) \x3d\x3d\x3d objectType) {\n\t      Utils.extend(this.partials, name);\n\t    } else {\n\t      if (typeof partial \x3d\x3d\x3d 'undefined') {\n\t        throw new _Exception2['default']('Attempting to register a partial as undefined');\n\t      }\n\t      this.partials[name] \x3d partial;\n\t    }\n\t  },\n\t  unregisterPartial: function unregisterPartial(name) {\n\t    delete this.partials[name];\n\t  }\n\t};\n\n\tfunction registerDefaultHelpers(instance) {\n\t  instance.registerHelper('helperMissing', function () {\n\t    if (arguments.length \x3d\x3d\x3d 1) {\n\t      // A missing field in a {{foo}} constuct.\n\t      return undefined;\n\t    } else {\n\t      // Someone is actually trying to call something, blow up.\n\t      throw new _Exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n\t    }\n\t  });\n\n\t  instance.registerHelper('blockHelperMissing', function (context, options) {\n\t    var inverse \x3d options.inverse,\n\t        fn \x3d options.fn;\n\n\t    if (context \x3d\x3d\x3d true) {\n\t      return fn(this);\n\t    } else if (context \x3d\x3d\x3d false || context \x3d\x3d null) {\n\t      return inverse(this);\n\t    } else if (isArray(context)) {\n\t      if (context.length \x3e 0) {\n\t        if (options.ids) {\n\t          options.ids \x3d [options.name];\n\t        }\n\n\t        return instance.helpers.each(context, options);\n\t      } else {\n\t        return inverse(this);\n\t      }\n\t    } else {\n\t      if (options.data \x26\x26 options.ids) {\n\t        var data \x3d createFrame(options.data);\n\t        data.contextPath \x3d Utils.appendContextPath(options.data.contextPath, options.name);\n\t        options \x3d { data: data };\n\t      }\n\n\t      return fn(context, options);\n\t    }\n\t  });\n\n\t  instance.registerHelper('each', function (context, options) {\n\t    if (!options) {\n\t      throw new _Exception2['default']('Must pass iterator to #each');\n\t    }\n\n\t    var fn \x3d options.fn,\n\t        inverse \x3d options.inverse,\n\t        i \x3d 0,\n\t        ret \x3d '',\n\t        data \x3d undefined,\n\t        contextPath \x3d undefined;\n\n\t    if (options.data \x26\x26 options.ids) {\n\t      contextPath \x3d Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n\t    }\n\n\t    if (isFunction(context)) {\n\t      context \x3d context.call(this);\n\t    }\n\n\t    if (options.data) {\n\t      data \x3d createFrame(options.data);\n\t    }\n\n\t    function execIteration(field, index, last) {\n\t      if (data) {\n\t        data.key \x3d field;\n\t        data.index \x3d index;\n\t        data.first \x3d index \x3d\x3d\x3d 0;\n\t        data.last \x3d !!last;\n\n\t        if (contextPath) {\n\t          data.contextPath \x3d contextPath + field;\n\t        }\n\t      }\n\n\t      ret \x3d ret + fn(context[field], {\n\t        data: data,\n\t        blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])\n\t      });\n\t    }\n\n\t    if (context \x26\x26 typeof context \x3d\x3d\x3d 'object') {\n\t      if (isArray(context)) {\n\t        for (var j \x3d context.length; i \x3c j; i++) {\n\t          execIteration(i, i, i \x3d\x3d\x3d context.length - 1);\n\t        }\n\t      } else {\n\t        var priorKey \x3d undefined;\n\n\t        for (var key in context) {\n\t          if (context.hasOwnProperty(key)) {\n\t            // We're running the iterations one step out of sync so we can detect\n\t            // the last iteration without have to scan the object twice and create\n\t            // an itermediate keys array.\n\t            if (priorKey) {\n\t              execIteration(priorKey, i - 1);\n\t            }\n\t            priorKey \x3d key;\n\t            i++;\n\t          }\n\t        }\n\t        if (priorKey) {\n\t          execIteration(priorKey, i - 1, true);\n\t        }\n\t      }\n\t    }\n\n\t    if (i \x3d\x3d\x3d 0) {\n\t      ret \x3d inverse(this);\n\t    }\n\n\t    return ret;\n\t  });\n\n\t  instance.registerHelper('if', function (conditional, options) {\n\t    if (isFunction(conditional)) {\n\t      conditional \x3d conditional.call(this);\n\t    }\n\n\t    // Default behavior is to render the positive path if the value is truthy and not empty.\n\t    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n\t    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n\t    if (!options.hash.includeZero \x26\x26 !conditional || Utils.isEmpty(conditional)) {\n\t      return options.inverse(this);\n\t    } else {\n\t      return options.fn(this);\n\t    }\n\t  });\n\n\t  instance.registerHelper('unless', function (conditional, options) {\n\t    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n\t  });\n\n\t  instance.registerHelper('with', function (context, options) {\n\t    if (isFunction(context)) {\n\t      context \x3d context.call(this);\n\t    }\n\n\t    var fn \x3d options.fn;\n\n\t    if (!Utils.isEmpty(context)) {\n\t      if (options.data \x26\x26 options.ids) {\n\t        var data \x3d createFrame(options.data);\n\t        data.contextPath \x3d Utils.appendContextPath(options.data.contextPath, options.ids[0]);\n\t        options \x3d { data: data };\n\t      }\n\n\t      return fn(context, options);\n\t    } else {\n\t      return options.inverse(this);\n\t    }\n\t  });\n\n\t  instance.registerHelper('log', function (message, options) {\n\t    var level \x3d options.data \x26\x26 options.data.level !\x3d null ? parseInt(options.data.level, 10) : 1;\n\t    instance.log(level, message);\n\t  });\n\n\t  instance.registerHelper('lookup', function (obj, field) {\n\t    return obj \x26\x26 obj[field];\n\t  });\n\t}\n\n\tvar logger \x3d {\n\t  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },\n\n\t  // State enum\n\t  DEBUG: 0,\n\t  INFO: 1,\n\t  WARN: 2,\n\t  ERROR: 3,\n\t  level: 1,\n\n\t  // Can be overridden in the host environment\n\t  log: function log(level, message) {\n\t    if (typeof console !\x3d\x3d 'undefined' \x26\x26 logger.level \x3c\x3d level) {\n\t      var method \x3d logger.methodMap[level];\n\t      (console[method] || console.log).call(console, message); // eslint-disable-line no-console\n\t    }\n\t  }\n\t};\n\n\texports.logger \x3d logger;\n\tvar log \x3d logger.log;\n\n\texports.log \x3d log;\n\n\tfunction createFrame(object) {\n\t  var frame \x3d Utils.extend({}, object);\n\t  frame._parent \x3d object;\n\t  return frame;\n\t}\n\n\t/* [args, ]options */\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule \x3d true;\n\t// Build out our basic SafeString type\n\tfunction SafeString(string) {\n\t  this.string \x3d string;\n\t}\n\n\tSafeString.prototype.toString \x3d SafeString.prototype.toHTML \x3d function () {\n\t  return '' + this.string;\n\t};\n\n\texports['default'] \x3d SafeString;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule \x3d true;\n\n\tvar errorProps \x3d ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\n\tfunction Exception(message, node) {\n\t  var loc \x3d node \x26\x26 node.loc,\n\t      line \x3d undefined,\n\t      column \x3d undefined;\n\t  if (loc) {\n\t    line \x3d loc.start.line;\n\t    column \x3d loc.start.column;\n\n\t    message +\x3d ' - ' + line + ':' + column;\n\t  }\n\n\t  var tmp \x3d Error.prototype.constructor.call(this, message);\n\n\t  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n\t  for (var idx \x3d 0; idx \x3c errorProps.length; idx++) {\n\t    this[errorProps[idx]] \x3d tmp[errorProps[idx]];\n\t  }\n\n\t  if (Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, Exception);\n\t  }\n\n\t  if (loc) {\n\t    this.lineNumber \x3d line;\n\t    this.column \x3d column;\n\t  }\n\t}\n\n\tException.prototype \x3d new Error();\n\n\texports['default'] \x3d Exception;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule \x3d true;\n\texports.extend \x3d extend;\n\n\t// Older IE versions do not directly support indexOf so we must implement our own, sadly.\n\texports.indexOf \x3d indexOf;\n\texports.escapeExpression \x3d escapeExpression;\n\texports.isEmpty \x3d isEmpty;\n\texports.blockParams \x3d blockParams;\n\texports.appendContextPath \x3d appendContextPath;\n\tvar escape \x3d {\n\t  '\x26': '\x26amp;',\n\t  '\x3c': '\x26lt;',\n\t  '\x3e': '\x26gt;',\n\t  '\"': '\x26quot;',\n\t  '\\'': '\x26#x27;',\n\t  '`': '\x26#x60;'\n\t};\n\n\tvar badChars \x3d /[\x26\x3c\x3e\"'`]/g,\n\t    possible \x3d /[\x26\x3c\x3e\"'`]/;\n\n\tfunction escapeChar(chr) {\n\t  return escape[chr];\n\t}\n\n\tfunction extend(obj /* , ...source */) {\n\t  for (var i \x3d 1; i \x3c arguments.length; i++) {\n\t    for (var key in arguments[i]) {\n\t      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n\t        obj[key] \x3d arguments[i][key];\n\t      }\n\t    }\n\t  }\n\n\t  return obj;\n\t}\n\n\tvar toString \x3d Object.prototype.toString;\n\n\texports.toString \x3d toString;\n\t// Sourced from lodash\n\t// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n\t/*eslint-disable func-style, no-var */\n\tvar isFunction \x3d function isFunction(value) {\n\t  return typeof value \x3d\x3d\x3d 'function';\n\t};\n\t// fallback for older versions of Chrome and Safari\n\t/* istanbul ignore next */\n\tif (isFunction(/x/)) {\n\t  exports.isFunction \x3d isFunction \x3d function (value) {\n\t    return typeof value \x3d\x3d\x3d 'function' \x26\x26 toString.call(value) \x3d\x3d\x3d '[object Function]';\n\t  };\n\t}\n\tvar isFunction;\n\texports.isFunction \x3d isFunction;\n\t/*eslint-enable func-style, no-var */\n\n\t/* istanbul ignore next */\n\tvar isArray \x3d Array.isArray || function (value) {\n\t  return value \x26\x26 typeof value \x3d\x3d\x3d 'object' ? toString.call(value) \x3d\x3d\x3d '[object Array]' : false;\n\t};exports.isArray \x3d isArray;\n\n\tfunction indexOf(array, value) {\n\t  for (var i \x3d 0, len \x3d array.length; i \x3c len; i++) {\n\t    if (array[i] \x3d\x3d\x3d value) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction escapeExpression(string) {\n\t  if (typeof string !\x3d\x3d 'string') {\n\t    // don't escape SafeStrings, since they're already safe\n\t    if (string \x26\x26 string.toHTML) {\n\t      return string.toHTML();\n\t    } else if (string \x3d\x3d null) {\n\t      return '';\n\t    } else if (!string) {\n\t      return string + '';\n\t    }\n\n\t    // Force a string conversion as this will be done by the append regardless and\n\t    // the regex test will do this transparently behind the scenes, causing issues if\n\t    // an object's to string has escaped characters in it.\n\t    string \x3d '' + string;\n\t  }\n\n\t  if (!possible.test(string)) {\n\t    return string;\n\t  }\n\t  return string.replace(badChars, escapeChar);\n\t}\n\n\tfunction isEmpty(value) {\n\t  if (!value \x26\x26 value !\x3d\x3d 0) {\n\t    return true;\n\t  } else if (isArray(value) \x26\x26 value.length \x3d\x3d\x3d 0) {\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction blockParams(params, ids) {\n\t  params.path \x3d ids;\n\t  return params;\n\t}\n\n\tfunction appendContextPath(contextPath, id) {\n\t  return (contextPath ? contextPath + '.' : '') + id;\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireWildcard \x3d __webpack_require__(9)['default'];\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\texports.checkRevision \x3d checkRevision;\n\n\t// TODO: Remove this line and break up compilePartial\n\n\texports.template \x3d template;\n\texports.wrapProgram \x3d wrapProgram;\n\texports.resolvePartial \x3d resolvePartial;\n\texports.invokePartial \x3d invokePartial;\n\texports.noop \x3d noop;\n\n\tvar _import \x3d __webpack_require__(13);\n\n\tvar Utils \x3d _interopRequireWildcard(_import);\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tvar _COMPILER_REVISION$REVISION_CHANGES$createFrame \x3d __webpack_require__(10);\n\n\tfunction checkRevision(compilerInfo) {\n\t  var compilerRevision \x3d compilerInfo \x26\x26 compilerInfo[0] || 1,\n\t      currentRevision \x3d _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;\n\n\t  if (compilerRevision !\x3d\x3d currentRevision) {\n\t    if (compilerRevision \x3c currentRevision) {\n\t      var runtimeVersions \x3d _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],\n\t          compilerVersions \x3d _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];\n\t      throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n\t    } else {\n\t      // Use the embedded version info since the runtime doesn't know about this revision yet\n\t      throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n\t    }\n\t  }\n\t}\n\n\tfunction template(templateSpec, env) {\n\t  /* istanbul ignore next */\n\t  if (!env) {\n\t    throw new _Exception2['default']('No environment passed to template');\n\t  }\n\t  if (!templateSpec || !templateSpec.main) {\n\t    throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);\n\t  }\n\n\t  // Note: Using env.VM references rather than local var references throughout this section to allow\n\t  // for external users to override these as psuedo-supported APIs.\n\t  env.VM.checkRevision(templateSpec.compiler);\n\n\t  function invokePartialWrapper(partial, context, options) {\n\t    if (options.hash) {\n\t      context \x3d Utils.extend({}, context, options.hash);\n\t    }\n\n\t    partial \x3d env.VM.resolvePartial.call(this, partial, context, options);\n\t    var result \x3d env.VM.invokePartial.call(this, partial, context, options);\n\n\t    if (result \x3d\x3d null \x26\x26 env.compile) {\n\t      options.partials[options.name] \x3d env.compile(partial, templateSpec.compilerOptions, env);\n\t      result \x3d options.partials[options.name](context, options);\n\t    }\n\t    if (result !\x3d null) {\n\t      if (options.indent) {\n\t        var lines \x3d result.split('\\n');\n\t        for (var i \x3d 0, l \x3d lines.length; i \x3c l; i++) {\n\t          if (!lines[i] \x26\x26 i + 1 \x3d\x3d\x3d l) {\n\t            break;\n\t          }\n\n\t          lines[i] \x3d options.indent + lines[i];\n\t        }\n\t        result \x3d lines.join('\\n');\n\t      }\n\t      return result;\n\t    } else {\n\t      throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n\t    }\n\t  }\n\n\t  // Just add water\n\t  var container \x3d {\n\t    strict: function strict(obj, name) {\n\t      if (!(name in obj)) {\n\t        throw new _Exception2['default']('\"' + name + '\" not defined in ' + obj);\n\t      }\n\t      return obj[name];\n\t    },\n\t    lookup: function lookup(depths, name) {\n\t      var len \x3d depths.length;\n\t      for (var i \x3d 0; i \x3c len; i++) {\n\t        if (depths[i] \x26\x26 depths[i][name] !\x3d null) {\n\t          return depths[i][name];\n\t        }\n\t      }\n\t    },\n\t    lambda: function lambda(current, context) {\n\t      return typeof current \x3d\x3d\x3d 'function' ? current.call(context) : current;\n\t    },\n\n\t    escapeExpression: Utils.escapeExpression,\n\t    invokePartial: invokePartialWrapper,\n\n\t    fn: function fn(i) {\n\t      return templateSpec[i];\n\t    },\n\n\t    programs: [],\n\t    program: function program(i, data, declaredBlockParams, blockParams, depths) {\n\t      var programWrapper \x3d this.programs[i],\n\t          fn \x3d this.fn(i);\n\t      if (data || depths || blockParams || declaredBlockParams) {\n\t        programWrapper \x3d wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n\t      } else if (!programWrapper) {\n\t        programWrapper \x3d this.programs[i] \x3d wrapProgram(this, i, fn);\n\t      }\n\t      return programWrapper;\n\t    },\n\n\t    data: function data(value, depth) {\n\t      while (value \x26\x26 depth--) {\n\t        value \x3d value._parent;\n\t      }\n\t      return value;\n\t    },\n\t    merge: function merge(param, common) {\n\t      var obj \x3d param || common;\n\n\t      if (param \x26\x26 common \x26\x26 param !\x3d\x3d common) {\n\t        obj \x3d Utils.extend({}, common, param);\n\t      }\n\n\t      return obj;\n\t    },\n\n\t    noop: env.VM.noop,\n\t    compilerInfo: templateSpec.compiler\n\t  };\n\n\t  function ret(context) {\n\t    var options \x3d arguments[1] \x3d\x3d\x3d undefined ? {} : arguments[1];\n\n\t    var data \x3d options.data;\n\n\t    ret._setup(options);\n\t    if (!options.partial \x26\x26 templateSpec.useData) {\n\t      data \x3d initData(context, data);\n\t    }\n\t    var depths \x3d undefined,\n\t        blockParams \x3d templateSpec.useBlockParams ? [] : undefined;\n\t    if (templateSpec.useDepths) {\n\t      depths \x3d options.depths ? [context].concat(options.depths) : [context];\n\t    }\n\n\t    return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);\n\t  }\n\t  ret.isTop \x3d true;\n\n\t  ret._setup \x3d function (options) {\n\t    if (!options.partial) {\n\t      container.helpers \x3d container.merge(options.helpers, env.helpers);\n\n\t      if (templateSpec.usePartial) {\n\t        container.partials \x3d container.merge(options.partials, env.partials);\n\t      }\n\t    } else {\n\t      container.helpers \x3d options.helpers;\n\t      container.partials \x3d options.partials;\n\t    }\n\t  };\n\n\t  ret._child \x3d function (i, data, blockParams, depths) {\n\t    if (templateSpec.useBlockParams \x26\x26 !blockParams) {\n\t      throw new _Exception2['default']('must pass block params');\n\t    }\n\t    if (templateSpec.useDepths \x26\x26 !depths) {\n\t      throw new _Exception2['default']('must pass parent depths');\n\t    }\n\n\t    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n\t  };\n\t  return ret;\n\t}\n\n\tfunction wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n\t  function prog(context) {\n\t    var options \x3d arguments[1] \x3d\x3d\x3d undefined ? {} : arguments[1];\n\n\t    return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams \x26\x26 [options.blockParams].concat(blockParams), depths \x26\x26 [context].concat(depths));\n\t  }\n\t  prog.program \x3d i;\n\t  prog.depth \x3d depths ? depths.length : 0;\n\t  prog.blockParams \x3d declaredBlockParams || 0;\n\t  return prog;\n\t}\n\n\tfunction resolvePartial(partial, context, options) {\n\t  if (!partial) {\n\t    partial \x3d options.partials[options.name];\n\t  } else if (!partial.call \x26\x26 !options.name) {\n\t    // This is a dynamic partial that returned a string\n\t    options.name \x3d partial;\n\t    partial \x3d options.partials[partial];\n\t  }\n\t  return partial;\n\t}\n\n\tfunction invokePartial(partial, context, options) {\n\t  options.partial \x3d true;\n\n\t  if (partial \x3d\x3d\x3d undefined) {\n\t    throw new _Exception2['default']('The partial ' + options.name + ' could not be found');\n\t  } else if (partial instanceof Function) {\n\t    return partial(context, options);\n\t  }\n\t}\n\n\tfunction noop() {\n\t  return '';\n\t}\n\n\tfunction initData(context, data) {\n\t  if (!data || !('root' in data)) {\n\t    data \x3d data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};\n\t    data.root \x3d context;\n\t  }\n\t  return data;\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule \x3d true;\n\t/* istanbul ignore next */\n\t/* Jison generated parser */\n\tvar handlebars \x3d (function () {\n\t    var parser \x3d { trace: function trace() {},\n\t        yy: {},\n\t        symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, content: 12, COMMENT: 13, CONTENT: 14, openRawBlock: 15, END_RAW_BLOCK: 16, OPEN_RAW_BLOCK: 17, helperName: 18, openRawBlock_repetition0: 19, openRawBlock_option0: 20, CLOSE_RAW_BLOCK: 21, openBlock: 22, block_option0: 23, closeBlock: 24, openInverse: 25, block_option1: 26, OPEN_BLOCK: 27, openBlock_repetition0: 28, openBlock_option0: 29, openBlock_option1: 30, CLOSE: 31, OPEN_INVERSE: 32, openInverse_repetition0: 33, openInverse_option0: 34, openInverse_option1: 35, openInverseChain: 36, OPEN_INVERSE_CHAIN: 37, openInverseChain_repetition0: 38, openInverseChain_option0: 39, openInverseChain_option1: 40, inverseAndProgram: 41, INVERSE: 42, inverseChain: 43, inverseChain_option0: 44, OPEN_ENDBLOCK: 45, OPEN: 46, mustache_repetition0: 47, mustache_option0: 48, OPEN_UNESCAPED: 49, mustache_repetition1: 50, mustache_option1: 51, CLOSE_UNESCAPED: 52, OPEN_PARTIAL: 53, partialName: 54, partial_repetition0: 55, partial_option0: 56, param: 57, sexpr: 58, OPEN_SEXPR: 59, sexpr_repetition0: 60, sexpr_option0: 61, CLOSE_SEXPR: 62, hash: 63, hash_repetition_plus0: 64, hashSegment: 65, ID: 66, EQUALS: 67, blockParams: 68, OPEN_BLOCK_PARAMS: 69, blockParams_repetition_plus0: 70, CLOSE_BLOCK_PARAMS: 71, path: 72, dataName: 73, STRING: 74, NUMBER: 75, BOOLEAN: 76, UNDEFINED: 77, NULL: 78, DATA: 79, pathSegments: 80, SEP: 81, $accept: 0, $end: 1 },\n\t        terminals_: { 2: \"error\", 5: \"EOF\", 13: \"COMMENT\", 14: \"CONTENT\", 16: \"END_RAW_BLOCK\", 17: \"OPEN_RAW_BLOCK\", 21: \"CLOSE_RAW_BLOCK\", 27: \"OPEN_BLOCK\", 31: \"CLOSE\", 32: \"OPEN_INVERSE\", 37: \"OPEN_INVERSE_CHAIN\", 42: \"INVERSE\", 45: \"OPEN_ENDBLOCK\", 46: \"OPEN\", 49: \"OPEN_UNESCAPED\", 52: \"CLOSE_UNESCAPED\", 53: \"OPEN_PARTIAL\", 59: \"OPEN_SEXPR\", 62: \"CLOSE_SEXPR\", 66: \"ID\", 67: \"EQUALS\", 69: \"OPEN_BLOCK_PARAMS\", 71: \"CLOSE_BLOCK_PARAMS\", 74: \"STRING\", 75: \"NUMBER\", 76: \"BOOLEAN\", 77: \"UNDEFINED\", 78: \"NULL\", 79: \"DATA\", 81: \"SEP\" },\n\t        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [12, 1], [10, 3], [15, 5], [9, 4], [9, 4], [22, 6], [25, 6], [36, 6], [41, 2], [43, 3], [43, 1], [24, 3], [8, 5], [8, 5], [11, 5], [57, 1], [57, 1], [58, 5], [63, 1], [65, 3], [68, 3], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [54, 1], [54, 1], [73, 2], [72, 1], [80, 3], [80, 1], [6, 0], [6, 2], [19, 0], [19, 2], [20, 0], [20, 1], [23, 0], [23, 1], [26, 0], [26, 1], [28, 0], [28, 2], [29, 0], [29, 1], [30, 0], [30, 1], [33, 0], [33, 2], [34, 0], [34, 1], [35, 0], [35, 1], [38, 0], [38, 2], [39, 0], [39, 1], [40, 0], [40, 1], [44, 0], [44, 1], [47, 0], [47, 2], [48, 0], [48, 1], [50, 0], [50, 2], [51, 0], [51, 1], [55, 0], [55, 2], [56, 0], [56, 1], [60, 0], [60, 2], [61, 0], [61, 1], [64, 1], [64, 2], [70, 1], [70, 2]],\n\t        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n\n\t            var $0 \x3d $$.length - 1;\n\t            switch (yystate) {\n\t                case 1:\n\t                    return $$[$0 - 1];\n\t                    break;\n\t                case 2:\n\t                    this.$ \x3d new yy.Program($$[$0], null, {}, yy.locInfo(this._$));\n\t                    break;\n\t                case 3:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 4:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 5:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 6:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 7:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 8:\n\t                    this.$ \x3d new yy.CommentStatement(yy.stripComment($$[$0]), yy.stripFlags($$[$0], $$[$0]), yy.locInfo(this._$));\n\t                    break;\n\t                case 9:\n\t                    this.$ \x3d new yy.ContentStatement($$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 10:\n\t                    this.$ \x3d yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\n\t                    break;\n\t                case 11:\n\t                    this.$ \x3d { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };\n\t                    break;\n\t                case 12:\n\t                    this.$ \x3d yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);\n\t                    break;\n\t                case 13:\n\t                    this.$ \x3d yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);\n\t                    break;\n\t                case 14:\n\t                    this.$ \x3d { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n\t                    break;\n\t                case 15:\n\t                    this.$ \x3d { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n\t                    break;\n\t                case 16:\n\t                    this.$ \x3d { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n\t                    break;\n\t                case 17:\n\t                    this.$ \x3d { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };\n\t                    break;\n\t                case 18:\n\t                    var inverse \x3d yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),\n\t                        program \x3d new yy.Program([inverse], null, {}, yy.locInfo(this._$));\n\t                    program.chained \x3d true;\n\n\t                    this.$ \x3d { strip: $$[$0 - 2].strip, program: program, chain: true };\n\n\t                    break;\n\t                case 19:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 20:\n\t                    this.$ \x3d { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };\n\t                    break;\n\t                case 21:\n\t                    this.$ \x3d yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n\t                    break;\n\t                case 22:\n\t                    this.$ \x3d yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n\t                    break;\n\t                case 23:\n\t                    this.$ \x3d new yy.PartialStatement($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.stripFlags($$[$0 - 4], $$[$0]), yy.locInfo(this._$));\n\t                    break;\n\t                case 24:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 25:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 26:\n\t                    this.$ \x3d new yy.SubExpression($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.locInfo(this._$));\n\t                    break;\n\t                case 27:\n\t                    this.$ \x3d new yy.Hash($$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 28:\n\t                    this.$ \x3d new yy.HashPair(yy.id($$[$0 - 2]), $$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 29:\n\t                    this.$ \x3d yy.id($$[$0 - 1]);\n\t                    break;\n\t                case 30:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 31:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 32:\n\t                    this.$ \x3d new yy.StringLiteral($$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 33:\n\t                    this.$ \x3d new yy.NumberLiteral($$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 34:\n\t                    this.$ \x3d new yy.BooleanLiteral($$[$0], yy.locInfo(this._$));\n\t                    break;\n\t                case 35:\n\t                    this.$ \x3d new yy.UndefinedLiteral(yy.locInfo(this._$));\n\t                    break;\n\t                case 36:\n\t                    this.$ \x3d new yy.NullLiteral(yy.locInfo(this._$));\n\t                    break;\n\t                case 37:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 38:\n\t                    this.$ \x3d $$[$0];\n\t                    break;\n\t                case 39:\n\t                    this.$ \x3d yy.preparePath(true, $$[$0], this._$);\n\t                    break;\n\t                case 40:\n\t                    this.$ \x3d yy.preparePath(false, $$[$0], this._$);\n\t                    break;\n\t                case 41:\n\t                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ \x3d $$[$0 - 2];\n\t                    break;\n\t                case 42:\n\t                    this.$ \x3d [{ part: yy.id($$[$0]), original: $$[$0] }];\n\t                    break;\n\t                case 43:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 44:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 45:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 46:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 53:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 54:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 59:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 60:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 65:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 66:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 73:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 74:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 77:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 78:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 81:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 82:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 85:\n\t                    this.$ \x3d [];\n\t                    break;\n\t                case 86:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 89:\n\t                    this.$ \x3d [$$[$0]];\n\t                    break;\n\t                case 90:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t                case 91:\n\t                    this.$ \x3d [$$[$0]];\n\t                    break;\n\t                case 92:\n\t                    $$[$0 - 1].push($$[$0]);\n\t                    break;\n\t            }\n\t        },\n\t        table: [{ 3: 1, 4: 2, 5: [2, 43], 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: [1, 11], 14: [1, 18], 15: 16, 17: [1, 21], 22: 14, 25: 15, 27: [1, 19], 32: [1, 20], 37: [2, 2], 42: [2, 2], 45: [2, 2], 46: [1, 12], 49: [1, 13], 53: [1, 17] }, { 1: [2, 1] }, { 5: [2, 44], 13: [2, 44], 14: [2, 44], 17: [2, 44], 27: [2, 44], 32: [2, 44], 37: [2, 44], 42: [2, 44], 45: [2, 44], 46: [2, 44], 49: [2, 44], 53: [2, 44] }, { 5: [2, 3], 13: [2, 3], 14: [2, 3], 17: [2, 3], 27: [2, 3], 32: [2, 3], 37: [2, 3], 42: [2, 3], 45: [2, 3], 46: [2, 3], 49: [2, 3], 53: [2, 3] }, { 5: [2, 4], 13: [2, 4], 14: [2, 4], 17: [2, 4], 27: [2, 4], 32: [2, 4], 37: [2, 4], 42: [2, 4], 45: [2, 4], 46: [2, 4], 49: [2, 4], 53: [2, 4] }, { 5: [2, 5], 13: [2, 5], 14: [2, 5], 17: [2, 5], 27: [2, 5], 32: [2, 5], 37: [2, 5], 42: [2, 5], 45: [2, 5], 46: [2, 5], 49: [2, 5], 53: [2, 5] }, { 5: [2, 6], 13: [2, 6], 14: [2, 6], 17: [2, 6], 27: [2, 6], 32: [2, 6], 37: [2, 6], 42: [2, 6], 45: [2, 6], 46: [2, 6], 49: [2, 6], 53: [2, 6] }, { 5: [2, 7], 13: [2, 7], 14: [2, 7], 17: [2, 7], 27: [2, 7], 32: [2, 7], 37: [2, 7], 42: [2, 7], 45: [2, 7], 46: [2, 7], 49: [2, 7], 53: [2, 7] }, { 5: [2, 8], 13: [2, 8], 14: [2, 8], 17: [2, 8], 27: [2, 8], 32: [2, 8], 37: [2, 8], 42: [2, 8], 45: [2, 8], 46: [2, 8], 49: [2, 8], 53: [2, 8] }, { 18: 22, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 33, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 34, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 4: 35, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 12: 36, 14: [1, 18] }, { 18: 38, 54: 37, 58: 39, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 9], 13: [2, 9], 14: [2, 9], 16: [2, 9], 17: [2, 9], 27: [2, 9], 32: [2, 9], 37: [2, 9], 42: [2, 9], 45: [2, 9], 46: [2, 9], 49: [2, 9], 53: [2, 9] }, { 18: 41, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 42, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 43, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [2, 73], 47: 44, 59: [2, 73], 66: [2, 73], 74: [2, 73], 75: [2, 73], 76: [2, 73], 77: [2, 73], 78: [2, 73], 79: [2, 73] }, { 21: [2, 30], 31: [2, 30], 52: [2, 30], 59: [2, 30], 62: [2, 30], 66: [2, 30], 69: [2, 30], 74: [2, 30], 75: [2, 30], 76: [2, 30], 77: [2, 30], 78: [2, 30], 79: [2, 30] }, { 21: [2, 31], 31: [2, 31], 52: [2, 31], 59: [2, 31], 62: [2, 31], 66: [2, 31], 69: [2, 31], 74: [2, 31], 75: [2, 31], 76: [2, 31], 77: [2, 31], 78: [2, 31], 79: [2, 31] }, { 21: [2, 32], 31: [2, 32], 52: [2, 32], 59: [2, 32], 62: [2, 32], 66: [2, 32], 69: [2, 32], 74: [2, 32], 75: [2, 32], 76: [2, 32], 77: [2, 32], 78: [2, 32], 79: [2, 32] }, { 21: [2, 33], 31: [2, 33], 52: [2, 33], 59: [2, 33], 62: [2, 33], 66: [2, 33], 69: [2, 33], 74: [2, 33], 75: [2, 33], 76: [2, 33], 77: [2, 33], 78: [2, 33], 79: [2, 33] }, { 21: [2, 34], 31: [2, 34], 52: [2, 34], 59: [2, 34], 62: [2, 34], 66: [2, 34], 69: [2, 34], 74: [2, 34], 75: [2, 34], 76: [2, 34], 77: [2, 34], 78: [2, 34], 79: [2, 34] }, { 21: [2, 35], 31: [2, 35], 52: [2, 35], 59: [2, 35], 62: [2, 35], 66: [2, 35], 69: [2, 35], 74: [2, 35], 75: [2, 35], 76: [2, 35], 77: [2, 35], 78: [2, 35], 79: [2, 35] }, { 21: [2, 36], 31: [2, 36], 52: [2, 36], 59: [2, 36], 62: [2, 36], 66: [2, 36], 69: [2, 36], 74: [2, 36], 75: [2, 36], 76: [2, 36], 77: [2, 36], 78: [2, 36], 79: [2, 36] }, { 21: [2, 40], 31: [2, 40], 52: [2, 40], 59: [2, 40], 62: [2, 40], 66: [2, 40], 69: [2, 40], 74: [2, 40], 75: [2, 40], 76: [2, 40], 77: [2, 40], 78: [2, 40], 79: [2, 40], 81: [1, 45] }, { 66: [1, 32], 80: 46 }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 50: 47, 52: [2, 77], 59: [2, 77], 66: [2, 77], 74: [2, 77], 75: [2, 77], 76: [2, 77], 77: [2, 77], 78: [2, 77], 79: [2, 77] }, { 23: 48, 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 49, 45: [2, 49] }, { 26: 54, 41: 55, 42: [1, 53], 45: [2, 51] }, { 16: [1, 56] }, { 31: [2, 81], 55: 57, 59: [2, 81], 66: [2, 81], 74: [2, 81], 75: [2, 81], 76: [2, 81], 77: [2, 81], 78: [2, 81], 79: [2, 81] }, { 31: [2, 37], 59: [2, 37], 66: [2, 37], 74: [2, 37], 75: [2, 37], 76: [2, 37], 77: [2, 37], 78: [2, 37], 79: [2, 37] }, { 31: [2, 38], 59: [2, 38], 66: [2, 38], 74: [2, 38], 75: [2, 38], 76: [2, 38], 77: [2, 38], 78: [2, 38], 79: [2, 38] }, { 18: 58, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 28: 59, 31: [2, 53], 59: [2, 53], 66: [2, 53], 69: [2, 53], 74: [2, 53], 75: [2, 53], 76: [2, 53], 77: [2, 53], 78: [2, 53], 79: [2, 53] }, { 31: [2, 59], 33: 60, 59: [2, 59], 66: [2, 59], 69: [2, 59], 74: [2, 59], 75: [2, 59], 76: [2, 59], 77: [2, 59], 78: [2, 59], 79: [2, 59] }, { 19: 61, 21: [2, 45], 59: [2, 45], 66: [2, 45], 74: [2, 45], 75: [2, 45], 76: [2, 45], 77: [2, 45], 78: [2, 45], 79: [2, 45] }, { 18: 65, 31: [2, 75], 48: 62, 57: 63, 58: 66, 59: [1, 40], 63: 64, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 66: [1, 70] }, { 21: [2, 39], 31: [2, 39], 52: [2, 39], 59: [2, 39], 62: [2, 39], 66: [2, 39], 69: [2, 39], 74: [2, 39], 75: [2, 39], 76: [2, 39], 77: [2, 39], 78: [2, 39], 79: [2, 39], 81: [1, 45] }, { 18: 65, 51: 71, 52: [2, 79], 57: 72, 58: 66, 59: [1, 40], 63: 73, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 24: 74, 45: [1, 75] }, { 45: [2, 50] }, { 4: 76, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 45: [2, 19] }, { 18: 77, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 78, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 24: 79, 45: [1, 75] }, { 45: [2, 52] }, { 5: [2, 10], 13: [2, 10], 14: [2, 10], 17: [2, 10], 27: [2, 10], 32: [2, 10], 37: [2, 10], 42: [2, 10], 45: [2, 10], 46: [2, 10], 49: [2, 10], 53: [2, 10] }, { 18: 65, 31: [2, 83], 56: 80, 57: 81, 58: 66, 59: [1, 40], 63: 82, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 59: [2, 85], 60: 83, 62: [2, 85], 66: [2, 85], 74: [2, 85], 75: [2, 85], 76: [2, 85], 77: [2, 85], 78: [2, 85], 79: [2, 85] }, { 18: 65, 29: 84, 31: [2, 55], 57: 85, 58: 66, 59: [1, 40], 63: 86, 64: 67, 65: 68, 66: [1, 69], 69: [2, 55], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 31: [2, 61], 34: 87, 57: 88, 58: 66, 59: [1, 40], 63: 89, 64: 67, 65: 68, 66: [1, 69], 69: [2, 61], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 20: 90, 21: [2, 47], 57: 91, 58: 66, 59: [1, 40], 63: 92, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [1, 93] }, { 31: [2, 74], 59: [2, 74], 66: [2, 74], 74: [2, 74], 75: [2, 74], 76: [2, 74], 77: [2, 74], 78: [2, 74], 79: [2, 74] }, { 31: [2, 76] }, { 21: [2, 24], 31: [2, 24], 52: [2, 24], 59: [2, 24], 62: [2, 24], 66: [2, 24], 69: [2, 24], 74: [2, 24], 75: [2, 24], 76: [2, 24], 77: [2, 24], 78: [2, 24], 79: [2, 24] }, { 21: [2, 25], 31: [2, 25], 52: [2, 25], 59: [2, 25], 62: [2, 25], 66: [2, 25], 69: [2, 25], 74: [2, 25], 75: [2, 25], 76: [2, 25], 77: [2, 25], 78: [2, 25], 79: [2, 25] }, { 21: [2, 27], 31: [2, 27], 52: [2, 27], 62: [2, 27], 65: 94, 66: [1, 95], 69: [2, 27] }, { 21: [2, 89], 31: [2, 89], 52: [2, 89], 62: [2, 89], 66: [2, 89], 69: [2, 89] }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 67: [1, 96], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 21: [2, 41], 31: [2, 41], 52: [2, 41], 59: [2, 41], 62: [2, 41], 66: [2, 41], 69: [2, 41], 74: [2, 41], 75: [2, 41], 76: [2, 41], 77: [2, 41], 78: [2, 41], 79: [2, 41], 81: [2, 41] }, { 52: [1, 97] }, { 52: [2, 78], 59: [2, 78], 66: [2, 78], 74: [2, 78], 75: [2, 78], 76: [2, 78], 77: [2, 78], 78: [2, 78], 79: [2, 78] }, { 52: [2, 80] }, { 5: [2, 12], 13: [2, 12], 14: [2, 12], 17: [2, 12], 27: [2, 12], 32: [2, 12], 37: [2, 12], 42: [2, 12], 45: [2, 12], 46: [2, 12], 49: [2, 12], 53: [2, 12] }, { 18: 98, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 100, 44: 99, 45: [2, 71] }, { 31: [2, 65], 38: 101, 59: [2, 65], 66: [2, 65], 69: [2, 65], 74: [2, 65], 75: [2, 65], 76: [2, 65], 77: [2, 65], 78: [2, 65], 79: [2, 65] }, { 45: [2, 17] }, { 5: [2, 13], 13: [2, 13], 14: [2, 13], 17: [2, 13], 27: [2, 13], 32: [2, 13], 37: [2, 13], 42: [2, 13], 45: [2, 13], 46: [2, 13], 49: [2, 13], 53: [2, 13] }, { 31: [1, 102] }, { 31: [2, 82], 59: [2, 82], 66: [2, 82], 74: [2, 82], 75: [2, 82], 76: [2, 82], 77: [2, 82], 78: [2, 82], 79: [2, 82] }, { 31: [2, 84] }, { 18: 65, 57: 104, 58: 66, 59: [1, 40], 61: 103, 62: [2, 87], 63: 105, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 30: 106, 31: [2, 57], 68: 107, 69: [1, 108] }, { 31: [2, 54], 59: [2, 54], 66: [2, 54], 69: [2, 54], 74: [2, 54], 75: [2, 54], 76: [2, 54], 77: [2, 54], 78: [2, 54], 79: [2, 54] }, { 31: [2, 56], 69: [2, 56] }, { 31: [2, 63], 35: 109, 68: 110, 69: [1, 108] }, { 31: [2, 60], 59: [2, 60], 66: [2, 60], 69: [2, 60], 74: [2, 60], 75: [2, 60], 76: [2, 60], 77: [2, 60], 78: [2, 60], 79: [2, 60] }, { 31: [2, 62], 69: [2, 62] }, { 21: [1, 111] }, { 21: [2, 46], 59: [2, 46], 66: [2, 46], 74: [2, 46], 75: [2, 46], 76: [2, 46], 77: [2, 46], 78: [2, 46], 79: [2, 46] }, { 21: [2, 48] }, { 5: [2, 21], 13: [2, 21], 14: [2, 21], 17: [2, 21], 27: [2, 21], 32: [2, 21], 37: [2, 21], 42: [2, 21], 45: [2, 21], 46: [2, 21], 49: [2, 21], 53: [2, 21] }, { 21: [2, 90], 31: [2, 90], 52: [2, 90], 62: [2, 90], 66: [2, 90], 69: [2, 90] }, { 67: [1, 96] }, { 18: 65, 57: 112, 58: 66, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 22], 13: [2, 22], 14: [2, 22], 17: [2, 22], 27: [2, 22], 32: [2, 22], 37: [2, 22], 42: [2, 22], 45: [2, 22], 46: [2, 22], 49: [2, 22], 53: [2, 22] }, { 31: [1, 113] }, { 45: [2, 18] }, { 45: [2, 72] }, { 18: 65, 31: [2, 67], 39: 114, 57: 115, 58: 66, 59: [1, 40], 63: 116, 64: 67, 65: 68, 66: [1, 69], 69: [2, 67], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 23], 13: [2, 23], 14: [2, 23], 17: [2, 23], 27: [2, 23], 32: [2, 23], 37: [2, 23], 42: [2, 23], 45: [2, 23], 46: [2, 23], 49: [2, 23], 53: [2, 23] }, { 62: [1, 117] }, { 59: [2, 86], 62: [2, 86], 66: [2, 86], 74: [2, 86], 75: [2, 86], 76: [2, 86], 77: [2, 86], 78: [2, 86], 79: [2, 86] }, { 62: [2, 88] }, { 31: [1, 118] }, { 31: [2, 58] }, { 66: [1, 120], 70: 119 }, { 31: [1, 121] }, { 31: [2, 64] }, { 14: [2, 11] }, { 21: [2, 28], 31: [2, 28], 52: [2, 28], 62: [2, 28], 66: [2, 28], 69: [2, 28] }, { 5: [2, 20], 13: [2, 20], 14: [2, 20], 17: [2, 20], 27: [2, 20], 32: [2, 20], 37: [2, 20], 42: [2, 20], 45: [2, 20], 46: [2, 20], 49: [2, 20], 53: [2, 20] }, { 31: [2, 69], 40: 122, 68: 123, 69: [1, 108] }, { 31: [2, 66], 59: [2, 66], 66: [2, 66], 69: [2, 66], 74: [2, 66], 75: [2, 66], 76: [2, 66], 77: [2, 66], 78: [2, 66], 79: [2, 66] }, { 31: [2, 68], 69: [2, 68] }, { 21: [2, 26], 31: [2, 26], 52: [2, 26], 59: [2, 26], 62: [2, 26], 66: [2, 26], 69: [2, 26], 74: [2, 26], 75: [2, 26], 76: [2, 26], 77: [2, 26], 78: [2, 26], 79: [2, 26] }, { 13: [2, 14], 14: [2, 14], 17: [2, 14], 27: [2, 14], 32: [2, 14], 37: [2, 14], 42: [2, 14], 45: [2, 14], 46: [2, 14], 49: [2, 14], 53: [2, 14] }, { 66: [1, 125], 71: [1, 124] }, { 66: [2, 91], 71: [2, 91] }, { 13: [2, 15], 14: [2, 15], 17: [2, 15], 27: [2, 15], 32: [2, 15], 42: [2, 15], 45: [2, 15], 46: [2, 15], 49: [2, 15], 53: [2, 15] }, { 31: [1, 126] }, { 31: [2, 70] }, { 31: [2, 29] }, { 66: [2, 92], 71: [2, 92] }, { 13: [2, 16], 14: [2, 16], 17: [2, 16], 27: [2, 16], 32: [2, 16], 37: [2, 16], 42: [2, 16], 45: [2, 16], 46: [2, 16], 49: [2, 16], 53: [2, 16] }],\n\t        defaultActions: { 4: [2, 1], 49: [2, 50], 51: [2, 19], 55: [2, 52], 64: [2, 76], 73: [2, 80], 78: [2, 17], 82: [2, 84], 92: [2, 48], 99: [2, 18], 100: [2, 72], 105: [2, 88], 107: [2, 58], 110: [2, 64], 111: [2, 11], 123: [2, 70], 124: [2, 29] },\n\t        parseError: function parseError(str, hash) {\n\t            throw new Error(str);\n\t        },\n\t        parse: function parse(input) {\n\t            var self \x3d this,\n\t                stack \x3d [0],\n\t                vstack \x3d [null],\n\t                lstack \x3d [],\n\t                table \x3d this.table,\n\t                yytext \x3d \"\",\n\t                yylineno \x3d 0,\n\t                yyleng \x3d 0,\n\t                recovering \x3d 0,\n\t                TERROR \x3d 2,\n\t                EOF \x3d 1;\n\t            this.lexer.setInput(input);\n\t            this.lexer.yy \x3d this.yy;\n\t            this.yy.lexer \x3d this.lexer;\n\t            this.yy.parser \x3d this;\n\t            if (typeof this.lexer.yylloc \x3d\x3d \"undefined\") this.lexer.yylloc \x3d {};\n\t            var yyloc \x3d this.lexer.yylloc;\n\t            lstack.push(yyloc);\n\t            var ranges \x3d this.lexer.options \x26\x26 this.lexer.options.ranges;\n\t            if (typeof this.yy.parseError \x3d\x3d\x3d \"function\") this.parseError \x3d this.yy.parseError;\n\t            function popStack(n) {\n\t                stack.length \x3d stack.length - 2 * n;\n\t                vstack.length \x3d vstack.length - n;\n\t                lstack.length \x3d lstack.length - n;\n\t            }\n\t            function lex() {\n\t                var token;\n\t                token \x3d self.lexer.lex() || 1;\n\t                if (typeof token !\x3d\x3d \"number\") {\n\t                    token \x3d self.symbols_[token] || token;\n\t                }\n\t                return token;\n\t            }\n\t            var symbol,\n\t                preErrorSymbol,\n\t                state,\n\t                action,\n\t                a,\n\t                r,\n\t                yyval \x3d {},\n\t                p,\n\t                len,\n\t                newState,\n\t                expected;\n\t            while (true) {\n\t                state \x3d stack[stack.length - 1];\n\t                if (this.defaultActions[state]) {\n\t                    action \x3d this.defaultActions[state];\n\t                } else {\n\t                    if (symbol \x3d\x3d\x3d null || typeof symbol \x3d\x3d \"undefined\") {\n\t                        symbol \x3d lex();\n\t                    }\n\t                    action \x3d table[state] \x26\x26 table[state][symbol];\n\t                }\n\t                if (typeof action \x3d\x3d\x3d \"undefined\" || !action.length || !action[0]) {\n\t                    var errStr \x3d \"\";\n\t                    if (!recovering) {\n\t                        expected \x3d [];\n\t                        for (p in table[state]) if (this.terminals_[p] \x26\x26 p \x3e 2) {\n\t                            expected.push(\"'\" + this.terminals_[p] + \"'\");\n\t                        }\n\t                        if (this.lexer.showPosition) {\n\t                            errStr \x3d \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n\t                        } else {\n\t                            errStr \x3d \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol \x3d\x3d 1 ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n\t                        }\n\t                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });\n\t                    }\n\t                }\n\t                if (action[0] instanceof Array \x26\x26 action.length \x3e 1) {\n\t                    throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n\t                }\n\t                switch (action[0]) {\n\t                    case 1:\n\t                        stack.push(symbol);\n\t                        vstack.push(this.lexer.yytext);\n\t                        lstack.push(this.lexer.yylloc);\n\t                        stack.push(action[1]);\n\t                        symbol \x3d null;\n\t                        if (!preErrorSymbol) {\n\t                            yyleng \x3d this.lexer.yyleng;\n\t                            yytext \x3d this.lexer.yytext;\n\t                            yylineno \x3d this.lexer.yylineno;\n\t                            yyloc \x3d this.lexer.yylloc;\n\t                            if (recovering \x3e 0) recovering--;\n\t                        } else {\n\t                            symbol \x3d preErrorSymbol;\n\t                            preErrorSymbol \x3d null;\n\t                        }\n\t                        break;\n\t                    case 2:\n\t                        len \x3d this.productions_[action[1]][1];\n\t                        yyval.$ \x3d vstack[vstack.length - len];\n\t                        yyval._$ \x3d { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };\n\t                        if (ranges) {\n\t                            yyval._$.range \x3d [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n\t                        }\n\t                        r \x3d this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\t                        if (typeof r !\x3d\x3d \"undefined\") {\n\t                            return r;\n\t                        }\n\t                        if (len) {\n\t                            stack \x3d stack.slice(0, -1 * len * 2);\n\t                            vstack \x3d vstack.slice(0, -1 * len);\n\t                            lstack \x3d lstack.slice(0, -1 * len);\n\t                        }\n\t                        stack.push(this.productions_[action[1]][0]);\n\t                        vstack.push(yyval.$);\n\t                        lstack.push(yyval._$);\n\t                        newState \x3d table[stack[stack.length - 2]][stack[stack.length - 1]];\n\t                        stack.push(newState);\n\t                        break;\n\t                    case 3:\n\t                        return true;\n\t                }\n\t            }\n\t            return true;\n\t        }\n\t    };\n\t    /* Jison generated lexer */\n\t    var lexer \x3d (function () {\n\t        var lexer \x3d { EOF: 1,\n\t            parseError: function parseError(str, hash) {\n\t                if (this.yy.parser) {\n\t                    this.yy.parser.parseError(str, hash);\n\t                } else {\n\t                    throw new Error(str);\n\t                }\n\t            },\n\t            setInput: function setInput(input) {\n\t                this._input \x3d input;\n\t                this._more \x3d this._less \x3d this.done \x3d false;\n\t                this.yylineno \x3d this.yyleng \x3d 0;\n\t                this.yytext \x3d this.matched \x3d this.match \x3d \"\";\n\t                this.conditionStack \x3d [\"INITIAL\"];\n\t                this.yylloc \x3d { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };\n\t                if (this.options.ranges) this.yylloc.range \x3d [0, 0];\n\t                this.offset \x3d 0;\n\t                return this;\n\t            },\n\t            input: function input() {\n\t                var ch \x3d this._input[0];\n\t                this.yytext +\x3d ch;\n\t                this.yyleng++;\n\t                this.offset++;\n\t                this.match +\x3d ch;\n\t                this.matched +\x3d ch;\n\t                var lines \x3d ch.match(/(?:\\r\\n?|\\n).*/g);\n\t                if (lines) {\n\t                    this.yylineno++;\n\t                    this.yylloc.last_line++;\n\t                } else {\n\t                    this.yylloc.last_column++;\n\t                }\n\t                if (this.options.ranges) this.yylloc.range[1]++;\n\n\t                this._input \x3d this._input.slice(1);\n\t                return ch;\n\t            },\n\t            unput: function unput(ch) {\n\t                var len \x3d ch.length;\n\t                var lines \x3d ch.split(/(?:\\r\\n?|\\n)/g);\n\n\t                this._input \x3d ch + this._input;\n\t                this.yytext \x3d this.yytext.substr(0, this.yytext.length - len - 1);\n\t                //this.yyleng -\x3d len;\n\t                this.offset -\x3d len;\n\t                var oldLines \x3d this.match.split(/(?:\\r\\n?|\\n)/g);\n\t                this.match \x3d this.match.substr(0, this.match.length - 1);\n\t                this.matched \x3d this.matched.substr(0, this.matched.length - 1);\n\n\t                if (lines.length - 1) this.yylineno -\x3d lines.length - 1;\n\t                var r \x3d this.yylloc.range;\n\n\t                this.yylloc \x3d { first_line: this.yylloc.first_line,\n\t                    last_line: this.yylineno + 1,\n\t                    first_column: this.yylloc.first_column,\n\t                    last_column: lines ? (lines.length \x3d\x3d\x3d oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n\t                };\n\n\t                if (this.options.ranges) {\n\t                    this.yylloc.range \x3d [r[0], r[0] + this.yyleng - len];\n\t                }\n\t                return this;\n\t            },\n\t            more: function more() {\n\t                this._more \x3d true;\n\t                return this;\n\t            },\n\t            less: function less(n) {\n\t                this.unput(this.match.slice(n));\n\t            },\n\t            pastInput: function pastInput() {\n\t                var past \x3d this.matched.substr(0, this.matched.length - this.match.length);\n\t                return (past.length \x3e 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n\t            },\n\t            upcomingInput: function upcomingInput() {\n\t                var next \x3d this.match;\n\t                if (next.length \x3c 20) {\n\t                    next +\x3d this._input.substr(0, 20 - next.length);\n\t                }\n\t                return (next.substr(0, 20) + (next.length \x3e 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n\t            },\n\t            showPosition: function showPosition() {\n\t                var pre \x3d this.pastInput();\n\t                var c \x3d new Array(pre.length + 1).join(\"-\");\n\t                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n\t            },\n\t            next: function next() {\n\t                if (this.done) {\n\t                    return this.EOF;\n\t                }\n\t                if (!this._input) this.done \x3d true;\n\n\t                var token, match, tempMatch, index, col, lines;\n\t                if (!this._more) {\n\t                    this.yytext \x3d \"\";\n\t                    this.match \x3d \"\";\n\t                }\n\t                var rules \x3d this._currentRules();\n\t                for (var i \x3d 0; i \x3c rules.length; i++) {\n\t                    tempMatch \x3d this._input.match(this.rules[rules[i]]);\n\t                    if (tempMatch \x26\x26 (!match || tempMatch[0].length \x3e match[0].length)) {\n\t                        match \x3d tempMatch;\n\t                        index \x3d i;\n\t                        if (!this.options.flex) break;\n\t                    }\n\t                }\n\t                if (match) {\n\t                    lines \x3d match[0].match(/(?:\\r\\n?|\\n).*/g);\n\t                    if (lines) this.yylineno +\x3d lines.length;\n\t                    this.yylloc \x3d { first_line: this.yylloc.last_line,\n\t                        last_line: this.yylineno + 1,\n\t                        first_column: this.yylloc.last_column,\n\t                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length };\n\t                    this.yytext +\x3d match[0];\n\t                    this.match +\x3d match[0];\n\t                    this.matches \x3d match;\n\t                    this.yyleng \x3d this.yytext.length;\n\t                    if (this.options.ranges) {\n\t                        this.yylloc.range \x3d [this.offset, this.offset +\x3d this.yyleng];\n\t                    }\n\t                    this._more \x3d false;\n\t                    this._input \x3d this._input.slice(match[0].length);\n\t                    this.matched +\x3d match[0];\n\t                    token \x3d this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);\n\t                    if (this.done \x26\x26 this._input) this.done \x3d false;\n\t                    if (token) {\n\t                        return token;\n\t                    } else {\n\t                        return;\n\t                    }\n\t                }\n\t                if (this._input \x3d\x3d\x3d \"\") {\n\t                    return this.EOF;\n\t                } else {\n\t                    return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\n\t                }\n\t            },\n\t            lex: function lex() {\n\t                var r \x3d this.next();\n\t                if (typeof r !\x3d\x3d \"undefined\") {\n\t                    return r;\n\t                } else {\n\t                    return this.lex();\n\t                }\n\t            },\n\t            begin: function begin(condition) {\n\t                this.conditionStack.push(condition);\n\t            },\n\t            popState: function popState() {\n\t                return this.conditionStack.pop();\n\t            },\n\t            _currentRules: function _currentRules() {\n\t                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n\t            },\n\t            topState: function topState() {\n\t                return this.conditionStack[this.conditionStack.length - 2];\n\t            },\n\t            pushState: function begin(condition) {\n\t                this.begin(condition);\n\t            } };\n\t        lexer.options \x3d {};\n\t        lexer.performAction \x3d function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n\n\t            function strip(start, end) {\n\t                return yy_.yytext \x3d yy_.yytext.substr(start, yy_.yyleng - end);\n\t            }\n\n\t            var YYSTATE \x3d YY_START;\n\t            switch ($avoiding_name_collisions) {\n\t                case 0:\n\t                    if (yy_.yytext.slice(-2) \x3d\x3d\x3d \"\\\\\\\\\") {\n\t                        strip(0, 1);\n\t                        this.begin(\"mu\");\n\t                    } else if (yy_.yytext.slice(-1) \x3d\x3d\x3d \"\\\\\") {\n\t                        strip(0, 1);\n\t                        this.begin(\"emu\");\n\t                    } else {\n\t                        this.begin(\"mu\");\n\t                    }\n\t                    if (yy_.yytext) {\n\t                        return 14;\n\t                    }break;\n\t                case 1:\n\t                    return 14;\n\t                    break;\n\t                case 2:\n\t                    this.popState();\n\t                    return 14;\n\n\t                    break;\n\t                case 3:\n\t                    yy_.yytext \x3d yy_.yytext.substr(5, yy_.yyleng - 9);\n\t                    this.popState();\n\t                    return 16;\n\n\t                    break;\n\t                case 4:\n\t                    return 14;\n\t                    break;\n\t                case 5:\n\t                    this.popState();\n\t                    return 13;\n\n\t                    break;\n\t                case 6:\n\t                    return 59;\n\t                    break;\n\t                case 7:\n\t                    return 62;\n\t                    break;\n\t                case 8:\n\t                    return 17;\n\t                    break;\n\t                case 9:\n\t                    this.popState();\n\t                    this.begin(\"raw\");\n\t                    return 21;\n\n\t                    break;\n\t                case 10:\n\t                    return 53;\n\t                    break;\n\t                case 11:\n\t                    return 27;\n\t                    break;\n\t                case 12:\n\t                    return 45;\n\t                    break;\n\t                case 13:\n\t                    this.popState();return 42;\n\t                    break;\n\t                case 14:\n\t                    this.popState();return 42;\n\t                    break;\n\t                case 15:\n\t                    return 32;\n\t                    break;\n\t                case 16:\n\t                    return 37;\n\t                    break;\n\t                case 17:\n\t                    return 49;\n\t                    break;\n\t                case 18:\n\t                    return 46;\n\t                    break;\n\t                case 19:\n\t                    this.unput(yy_.yytext);\n\t                    this.popState();\n\t                    this.begin(\"com\");\n\n\t                    break;\n\t                case 20:\n\t                    this.popState();\n\t                    return 13;\n\n\t                    break;\n\t                case 21:\n\t                    return 46;\n\t                    break;\n\t                case 22:\n\t                    return 67;\n\t                    break;\n\t                case 23:\n\t                    return 66;\n\t                    break;\n\t                case 24:\n\t                    return 66;\n\t                    break;\n\t                case 25:\n\t                    return 81;\n\t                    break;\n\t                case 26:\n\t                    // ignore whitespace\n\t                    break;\n\t                case 27:\n\t                    this.popState();return 52;\n\t                    break;\n\t                case 28:\n\t                    this.popState();return 31;\n\t                    break;\n\t                case 29:\n\t                    yy_.yytext \x3d strip(1, 2).replace(/\\\\\"/g, \"\\\"\");return 74;\n\t                    break;\n\t                case 30:\n\t                    yy_.yytext \x3d strip(1, 2).replace(/\\\\'/g, \"'\");return 74;\n\t                    break;\n\t                case 31:\n\t                    return 79;\n\t                    break;\n\t                case 32:\n\t                    return 76;\n\t                    break;\n\t                case 33:\n\t                    return 76;\n\t                    break;\n\t                case 34:\n\t                    return 77;\n\t                    break;\n\t                case 35:\n\t                    return 78;\n\t                    break;\n\t                case 36:\n\t                    return 75;\n\t                    break;\n\t                case 37:\n\t                    return 69;\n\t                    break;\n\t                case 38:\n\t                    return 71;\n\t                    break;\n\t                case 39:\n\t                    return 66;\n\t                    break;\n\t                case 40:\n\t                    return 66;\n\t                    break;\n\t                case 41:\n\t                    return \"INVALID\";\n\t                    break;\n\t                case 42:\n\t                    return 5;\n\t                    break;\n\t            }\n\t        };\n\t        lexer.rules \x3d [/^(?:[^\\x00]*?(?\x3d(\\{\\{)))/, /^(?:[^\\x00]+)/, /^(?:[^\\x00]{2,}?(?\x3d(\\{\\{|\\\\\\{\\{|\\\\\\\\\\{\\{|$)))/, /^(?:\\{\\{\\{\\{\\/[^\\s!\"#%-,\\.\\/;-\x3e@\\[-\\^`\\{-~]+(?\x3d[\x3d}\\s\\/.])\\}\\}\\}\\})/, /^(?:[^\\x00]*?(?\x3d(\\{\\{\\{\\{\\/)))/, /^(?:[\\s\\S]*?--(~)?\\}\\})/, /^(?:\\()/, /^(?:\\))/, /^(?:\\{\\{\\{\\{)/, /^(?:\\}\\}\\}\\})/, /^(?:\\{\\{(~)?\x3e)/, /^(?:\\{\\{(~)?#)/, /^(?:\\{\\{(~)?\\/)/, /^(?:\\{\\{(~)?\\^\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\s*else\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\^)/, /^(?:\\{\\{(~)?\\s*else\\b)/, /^(?:\\{\\{(~)?\\{)/, /^(?:\\{\\{(~)?\x26)/, /^(?:\\{\\{(~)?!--)/, /^(?:\\{\\{(~)?![\\s\\S]*?\\}\\})/, /^(?:\\{\\{(~)?)/, /^(?:\x3d)/, /^(?:\\.\\.)/, /^(?:\\.(?\x3d([\x3d~}\\s\\/.)|])))/, /^(?:[\\/.])/, /^(?:\\s+)/, /^(?:\\}(~)?\\}\\})/, /^(?:(~)?\\}\\})/, /^(?:\"(\\\\[\"]|[^\"])*\")/, /^(?:'(\\\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?\x3d([~}\\s)])))/, /^(?:false(?\x3d([~}\\s)])))/, /^(?:undefined(?\x3d([~}\\s)])))/, /^(?:null(?\x3d([~}\\s)])))/, /^(?:-?[0-9]+(?:\\.[0-9]+)?(?\x3d([~}\\s)])))/, /^(?:as\\s+\\|)/, /^(?:\\|)/, /^(?:([^\\s!\"#%-,\\.\\/;-\x3e@\\[-\\^`\\{-~]+(?\x3d([\x3d~}\\s\\/.)|]))))/, /^(?:\\[[^\\]]*\\])/, /^(?:.)/, /^(?:$)/];\n\t        lexer.conditions \x3d { mu: { rules: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [5], inclusive: false }, raw: { rules: [3, 4], inclusive: false }, INITIAL: { rules: [0, 1, 42], inclusive: true } };\n\t        return lexer;\n\t    })();\n\t    parser.lexer \x3d lexer;\n\t    function Parser() {\n\t        this.yy \x3d {};\n\t    }Parser.prototype \x3d parser;parser.Parser \x3d Parser;\n\t    return new Parser();\n\t})();exports[\"default\"] \x3d handlebars;\n\tmodule.exports \x3d exports[\"default\"];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\n\tvar _Visitor \x3d __webpack_require__(6);\n\n\tvar _Visitor2 \x3d _interopRequireDefault(_Visitor);\n\n\tfunction WhitespaceControl() {}\n\tWhitespaceControl.prototype \x3d new _Visitor2['default']();\n\n\tWhitespaceControl.prototype.Program \x3d function (program) {\n\t  var isRoot \x3d !this.isRootSeen;\n\t  this.isRootSeen \x3d true;\n\n\t  var body \x3d program.body;\n\t  for (var i \x3d 0, l \x3d body.length; i \x3c l; i++) {\n\t    var current \x3d body[i],\n\t        strip \x3d this.accept(current);\n\n\t    if (!strip) {\n\t      continue;\n\t    }\n\n\t    var _isPrevWhitespace \x3d isPrevWhitespace(body, i, isRoot),\n\t        _isNextWhitespace \x3d isNextWhitespace(body, i, isRoot),\n\t        openStandalone \x3d strip.openStandalone \x26\x26 _isPrevWhitespace,\n\t        closeStandalone \x3d strip.closeStandalone \x26\x26 _isNextWhitespace,\n\t        inlineStandalone \x3d strip.inlineStandalone \x26\x26 _isPrevWhitespace \x26\x26 _isNextWhitespace;\n\n\t    if (strip.close) {\n\t      omitRight(body, i, true);\n\t    }\n\t    if (strip.open) {\n\t      omitLeft(body, i, true);\n\t    }\n\n\t    if (inlineStandalone) {\n\t      omitRight(body, i);\n\n\t      if (omitLeft(body, i)) {\n\t        // If we are on a standalone node, save the indent info for partials\n\t        if (current.type \x3d\x3d\x3d 'PartialStatement') {\n\t          // Pull out the whitespace from the final line\n\t          current.indent \x3d /([ \\t]+$)/.exec(body[i - 1].original)[1];\n\t        }\n\t      }\n\t    }\n\t    if (openStandalone) {\n\t      omitRight((current.program || current.inverse).body);\n\n\t      // Strip out the previous content node if it's whitespace only\n\t      omitLeft(body, i);\n\t    }\n\t    if (closeStandalone) {\n\t      // Always strip the next node\n\t      omitRight(body, i);\n\n\t      omitLeft((current.inverse || current.program).body);\n\t    }\n\t  }\n\n\t  return program;\n\t};\n\tWhitespaceControl.prototype.BlockStatement \x3d function (block) {\n\t  this.accept(block.program);\n\t  this.accept(block.inverse);\n\n\t  // Find the inverse program that is involed with whitespace stripping.\n\t  var program \x3d block.program || block.inverse,\n\t      inverse \x3d block.program \x26\x26 block.inverse,\n\t      firstInverse \x3d inverse,\n\t      lastInverse \x3d inverse;\n\n\t  if (inverse \x26\x26 inverse.chained) {\n\t    firstInverse \x3d inverse.body[0].program;\n\n\t    // Walk the inverse chain to find the last inverse that is actually in the chain.\n\t    while (lastInverse.chained) {\n\t      lastInverse \x3d lastInverse.body[lastInverse.body.length - 1].program;\n\t    }\n\t  }\n\n\t  var strip \x3d {\n\t    open: block.openStrip.open,\n\t    close: block.closeStrip.close,\n\n\t    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n\t    // so our parent can determine if we actually are standalone\n\t    openStandalone: isNextWhitespace(program.body),\n\t    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n\t  };\n\n\t  if (block.openStrip.close) {\n\t    omitRight(program.body, null, true);\n\t  }\n\n\t  if (inverse) {\n\t    var inverseStrip \x3d block.inverseStrip;\n\n\t    if (inverseStrip.open) {\n\t      omitLeft(program.body, null, true);\n\t    }\n\n\t    if (inverseStrip.close) {\n\t      omitRight(firstInverse.body, null, true);\n\t    }\n\t    if (block.closeStrip.open) {\n\t      omitLeft(lastInverse.body, null, true);\n\t    }\n\n\t    // Find standalone else statments\n\t    if (isPrevWhitespace(program.body) \x26\x26 isNextWhitespace(firstInverse.body)) {\n\t      omitLeft(program.body);\n\t      omitRight(firstInverse.body);\n\t    }\n\t  } else if (block.closeStrip.open) {\n\t    omitLeft(program.body, null, true);\n\t  }\n\n\t  return strip;\n\t};\n\n\tWhitespaceControl.prototype.MustacheStatement \x3d function (mustache) {\n\t  return mustache.strip;\n\t};\n\n\tWhitespaceControl.prototype.PartialStatement \x3d WhitespaceControl.prototype.CommentStatement \x3d function (node) {\n\t  /* istanbul ignore next */\n\t  var strip \x3d node.strip || {};\n\t  return {\n\t    inlineStandalone: true,\n\t    open: strip.open,\n\t    close: strip.close\n\t  };\n\t};\n\n\tfunction isPrevWhitespace(body, i, isRoot) {\n\t  if (i \x3d\x3d\x3d undefined) {\n\t    i \x3d body.length;\n\t  }\n\n\t  // Nodes that end with newlines are considered whitespace (but are special\n\t  // cased for strip operations)\n\t  var prev \x3d body[i - 1],\n\t      sibling \x3d body[i - 2];\n\t  if (!prev) {\n\t    return isRoot;\n\t  }\n\n\t  if (prev.type \x3d\x3d\x3d 'ContentStatement') {\n\t    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n\t  }\n\t}\n\tfunction isNextWhitespace(body, i, isRoot) {\n\t  if (i \x3d\x3d\x3d undefined) {\n\t    i \x3d -1;\n\t  }\n\n\t  var next \x3d body[i + 1],\n\t      sibling \x3d body[i + 2];\n\t  if (!next) {\n\t    return isRoot;\n\t  }\n\n\t  if (next.type \x3d\x3d\x3d 'ContentStatement') {\n\t    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n\t  }\n\t}\n\n\t// Marks the node to the right of the position as omitted.\n\t// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n\t//\n\t// If i is undefined, then the first child will be marked as such.\n\t//\n\t// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n\t// content is met.\n\tfunction omitRight(body, i, multiple) {\n\t  var current \x3d body[i \x3d\x3d null ? 0 : i + 1];\n\t  if (!current || current.type !\x3d\x3d 'ContentStatement' || !multiple \x26\x26 current.rightStripped) {\n\t    return;\n\t  }\n\n\t  var original \x3d current.value;\n\t  current.value \x3d current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n\t  current.rightStripped \x3d current.value !\x3d\x3d original;\n\t}\n\n\t// Marks the node to the left of the position as omitted.\n\t// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n\t//\n\t// If i is undefined then the last child will be marked as such.\n\t//\n\t// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n\t// content is met.\n\tfunction omitLeft(body, i, multiple) {\n\t  var current \x3d body[i \x3d\x3d null ? body.length - 1 : i - 1];\n\t  if (!current || current.type !\x3d\x3d 'ContentStatement' || !multiple \x26\x26 current.leftStripped) {\n\t    return;\n\t  }\n\n\t  // We omit the last node if it's whitespace only and not preceeded by a non-content node.\n\t  var original \x3d current.value;\n\t  current.value \x3d current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n\t  current.leftStripped \x3d current.value !\x3d\x3d original;\n\t  return current.leftStripped;\n\t}\n\n\texports['default'] \x3d WhitespaceControl;\n\tmodule.exports \x3d exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault \x3d __webpack_require__(8)['default'];\n\n\texports.__esModule \x3d true;\n\texports.SourceLocation \x3d SourceLocation;\n\texports.id \x3d id;\n\texports.stripFlags \x3d stripFlags;\n\texports.stripComment \x3d stripComment;\n\texports.preparePath \x3d preparePath;\n\texports.prepareMustache \x3d prepareMustache;\n\texports.prepareRawBlock \x3d prepareRawBlock;\n\texports.prepareBlock \x3d prepareBlock;\n\n\tvar _Exception \x3d __webpack_require__(12);\n\n\tvar _Exception2 \x3d _interopRequireDefault(_Exception);\n\n\tfunction SourceLocation(source, locInfo) {\n\t  this.source \x3d source;\n\t  this.start \x3d {\n\t    line: locInfo.first_line,\n\t    column: locInfo.first_column\n\t  };\n\t  this.end \x3d {\n\t    line: locInfo.last_line,\n\t    column: locInfo.last_column\n\t  };\n\t}\n\n\tfunction id(token) {\n\t  if (/^\\[.*\\]$/.test(token)) {\n\t    return token.substr(1, token.length - 2);\n\t  } else {\n\t    return token;\n\t  }\n\t}\n\n\tfunction stripFlags(open, close) {\n\t  return {\n\t    open: open.charAt(2) \x3d\x3d\x3d '~',\n\t    close: close.charAt(close.length - 3) \x3d\x3d\x3d '~'\n\t  };\n\t}\n\n\tfunction stripComment(comment) {\n\t  return comment.replace(/^\\{\\{~?\\!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n\t}\n\n\tfunction preparePath(data, parts, locInfo) {\n\t  locInfo \x3d this.locInfo(locInfo);\n\n\t  var original \x3d data ? '@' : '',\n\t      dig \x3d [],\n\t      depth \x3d 0,\n\t      depthString \x3d '';\n\n\t  for (var i \x3d 0, l \x3d parts.length; i \x3c l; i++) {\n\t    var part \x3d parts[i].part,\n\n\t    // If we have [] syntax then we do not treat path references as operators,\n\t    // i.e. foo.[this] resolves to approximately context.foo['this']\n\t    isLiteral \x3d parts[i].original !\x3d\x3d part;\n\t    original +\x3d (parts[i].separator || '') + part;\n\n\t    if (!isLiteral \x26\x26 (part \x3d\x3d\x3d '..' || part \x3d\x3d\x3d '.' || part \x3d\x3d\x3d 'this')) {\n\t      if (dig.length \x3e 0) {\n\t        throw new _Exception2['default']('Invalid path: ' + original, { loc: locInfo });\n\t      } else if (part \x3d\x3d\x3d '..') {\n\t        depth++;\n\t        depthString +\x3d '../';\n\t      }\n\t    } else {\n\t      dig.push(part);\n\t    }\n\t  }\n\n\t  return new this.PathExpression(data, depth, dig, original, locInfo);\n\t}\n\n\tfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n\t  // Must use charAt to support IE pre-10\n\t  var escapeFlag \x3d open.charAt(3) || open.charAt(2),\n\t      escaped \x3d escapeFlag !\x3d\x3d '{' \x26\x26 escapeFlag !\x3d\x3d '\x26';\n\n\t  return new this.MustacheStatement(path, params, hash, escaped, strip, this.locInfo(locInfo));\n\t}\n\n\tfunction prepareRawBlock(openRawBlock, content, close, locInfo) {\n\t  if (openRawBlock.path.original !\x3d\x3d close) {\n\t    var errorNode \x3d { loc: openRawBlock.path.loc };\n\n\t    throw new _Exception2['default'](openRawBlock.path.original + ' doesn\\'t match ' + close, errorNode);\n\t  }\n\n\t  locInfo \x3d this.locInfo(locInfo);\n\t  var program \x3d new this.Program([content], null, {}, locInfo);\n\n\t  return new this.BlockStatement(openRawBlock.path, openRawBlock.params, openRawBlock.hash, program, undefined, {}, {}, {}, locInfo);\n\t}\n\n\tfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n\t  // When we are chaining inverse calls, we will not have a close path\n\t  if (close \x26\x26 close.path \x26\x26 openBlock.path.original !\x3d\x3d close.path.original) {\n\t    var errorNode \x3d { loc: openBlock.path.loc };\n\n\t    throw new _Exception2['default'](openBlock.path.original + ' doesn\\'t match ' + close.path.original, errorNode);\n\t  }\n\n\t  program.blockParams \x3d openBlock.blockParams;\n\n\t  var inverse \x3d undefined,\n\t      inverseStrip \x3d undefined;\n\n\t  if (inverseAndProgram) {\n\t    if (inverseAndProgram.chain) {\n\t      inverseAndProgram.program.body[0].closeStrip \x3d close.strip;\n\t    }\n\n\t    inverseStrip \x3d inverseAndProgram.strip;\n\t    inverse \x3d inverseAndProgram.program;\n\t  }\n\n\t  if (inverted) {\n\t    inverted \x3d inverse;\n\t    inverse \x3d program;\n\t    program \x3d inverted;\n\t  }\n\n\t  return new this.BlockStatement(openBlock.path, openBlock.params, openBlock.hash, program, inverse, openBlock.strip, inverseStrip, close \x26\x26 close.strip, this.locInfo(locInfo));\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule \x3d true;\n\t/*global define */\n\n\tvar _isArray \x3d __webpack_require__(13);\n\n\tvar SourceNode \x3d undefined;\n\n\ttry {\n\t  /* istanbul ignore next */\n\t  if (false) {\n\t    // We don't support this in AMD environments. For these environments, we asusme that\n\t    // they are running on the browser and thus have no need for the source-map library.\n\t    var SourceMap \x3d require('source-map');\n\t    SourceNode \x3d SourceMap.SourceNode;\n\t  }\n\t} catch (err) {}\n\n\t/* istanbul ignore if: tested but not covered in istanbul due to dist build  */\n\tif (!SourceNode) {\n\t  SourceNode \x3d function (line, column, srcFile, chunks) {\n\t    this.src \x3d '';\n\t    if (chunks) {\n\t      this.add(chunks);\n\t    }\n\t  };\n\t  /* istanbul ignore next */\n\t  SourceNode.prototype \x3d {\n\t    add: function add(chunks) {\n\t      if (_isArray.isArray(chunks)) {\n\t        chunks \x3d chunks.join('');\n\t      }\n\t      this.src +\x3d chunks;\n\t    },\n\t    prepend: function prepend(chunks) {\n\t      if (_isArray.isArray(chunks)) {\n\t        chunks \x3d chunks.join('');\n\t      }\n\t      this.src \x3d chunks + this.src;\n\t    },\n\t    toStringWithSourceMap: function toStringWithSourceMap() {\n\t      return { code: this.toString() };\n\t    },\n\t    toString: function toString() {\n\t      return this.src;\n\t    }\n\t  };\n\t}\n\n\tfunction castChunk(chunk, codeGen, loc) {\n\t  if (_isArray.isArray(chunk)) {\n\t    var ret \x3d [];\n\n\t    for (var i \x3d 0, len \x3d chunk.length; i \x3c len; i++) {\n\t      ret.push(codeGen.wrap(chunk[i], loc));\n\t    }\n\t    return ret;\n\t  } else if (typeof chunk \x3d\x3d\x3d 'boolean' || typeof chunk \x3d\x3d\x3d 'number') {\n\t    // Handle primitives that the SourceNode will throw up on\n\t    return chunk + '';\n\t  }\n\t  return chunk;\n\t}\n\n\tfunction CodeGen(srcFile) {\n\t  this.srcFile \x3d srcFile;\n\t  this.source \x3d [];\n\t}\n\n\tCodeGen.prototype \x3d {\n\t  prepend: function prepend(source, loc) {\n\t    this.source.unshift(this.wrap(source, loc));\n\t  },\n\t  push: function push(source, loc) {\n\t    this.source.push(this.wrap(source, loc));\n\t  },\n\n\t  merge: function merge() {\n\t    var source \x3d this.empty();\n\t    this.each(function (line) {\n\t      source.add(['  ', line, '\\n']);\n\t    });\n\t    return source;\n\t  },\n\n\t  each: function each(iter) {\n\t    for (var i \x3d 0, len \x3d this.source.length; i \x3c len; i++) {\n\t      iter(this.source[i]);\n\t    }\n\t  },\n\n\t  empty: function empty() {\n\t    var loc \x3d arguments[0] \x3d\x3d\x3d undefined ? this.currentLocation || { start: {} } : arguments[0];\n\n\t    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);\n\t  },\n\t  wrap: function wrap(chunk) {\n\t    var loc \x3d arguments[1] \x3d\x3d\x3d undefined ? this.currentLocation || { start: {} } : arguments[1];\n\n\t    if (chunk instanceof SourceNode) {\n\t      return chunk;\n\t    }\n\n\t    chunk \x3d castChunk(chunk, this, loc);\n\n\t    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);\n\t  },\n\n\t  functionCall: function functionCall(fn, type, params) {\n\t    params \x3d this.generateList(params);\n\t    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);\n\t  },\n\n\t  quotedString: function quotedString(str) {\n\t    return '\"' + (str + '').replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\u2028/g, '\\\\u2028') // Per Ecma-262 7.3 + 7.8.4\n\t    .replace(/\\u2029/g, '\\\\u2029') + '\"';\n\t  },\n\n\t  objectLiteral: function objectLiteral(obj) {\n\t    var pairs \x3d [];\n\n\t    for (var key in obj) {\n\t      if (obj.hasOwnProperty(key)) {\n\t        var value \x3d castChunk(obj[key], this);\n\t        if (value !\x3d\x3d 'undefined') {\n\t          pairs.push([this.quotedString(key), ':', value]);\n\t        }\n\t      }\n\t    }\n\n\t    var ret \x3d this.generateList(pairs);\n\t    ret.prepend('{');\n\t    ret.add('}');\n\t    return ret;\n\t  },\n\n\t  generateList: function generateList(entries, loc) {\n\t    var ret \x3d this.empty(loc);\n\n\t    for (var i \x3d 0, len \x3d entries.length; i \x3c len; i++) {\n\t      if (i) {\n\t        ret.add(',');\n\t      }\n\n\t      ret.add(castChunk(entries[i], this, loc));\n\t    }\n\n\t    return ret;\n\t  },\n\n\t  generateArray: function generateArray(entries, loc) {\n\t    var ret \x3d this.generateList(entries, loc);\n\t    ret.prepend('[');\n\t    ret.add(']');\n\n\t    return ret;\n\t  }\n\t};\n\n\texports['default'] \x3d CodeGen;\n\tmodule.exports \x3d exports['default'];\n\n\t/* NOP */\n\n/***/ }\n/******/ ])\n});\n;"},
1953:function(g,f,b){var e;delete (e=App.imageSizeWidths).mini;Handlebars.registerHelper("imgSrcSet",function(d,a,h){var b=Handlebars.escapeExpression;h=h||"large";a=a?'sizes\x3d"'+b(a)+'"':'sizes\x3d"100vw"';var c=[];return Object.keys(e).forEach(function(a){e[a]<=e[h]&&(!d||d[a])&&c.push(b(d[a])+" "+e[a]+"w")}),c.length?(c.reverse(),new Handlebars.SafeString(a+' srcset\x3d"'+c.join(",")+'"')):null});Handlebars.registerHelper("check",function(d,a,b){if(void 0===b&&(a=""),void 0===d&&void 0===b)throw"Error: value is undefined and no default value was given";
return d||a});Handlebars.registerHelper("ternary",function(b,a,e){return b?a:e});Handlebars.registerHelper("_js",function(){return _js.apply(window,arguments)})},1954:function(g,f,b){Object.defineProperty(f,"__esModule",{value:!0});f.Template=window.Template=function(){function b(a){var b=Handlebars.compile(a);return function(a,c){a=b(a);c?c=a:(c=$.parseHTML?$.parseHTML(a):(new Element("div",{html:a})).getChildren(),c=1===c.length?c[0]:c);return c}}var d={};return{get:function(a){return d[a]||(d[a]=
b(a)),d[a]}}}()}},[[1950,0,1]]]);
